{"version":3,"sources":["onnx/yolo/model/tinyyolov2-7.onnx","videos/sample_720p.mp4","onnx/yolo/utils/yoloPostprocessUtils.ts","onnx/yolo/utils/binary-op.ts","onnx/yolo/utils/concat.ts","onnx/yolo/utils/softmax.ts","onnx/yolo/utils/transpose.ts","onnx/yolo/utils/yoloPostprocess.ts","onnx/yolo/utils/unary-op.ts","onnx/yolo/utils/reshape.ts","onnx/yolo/model/yolo_classes.ts","onnx/yolo/yolo.ts","common/video-loader.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["ndarray","require","BroadcastUtil","adims","bdims","isMatMul","arank","length","brank","crank","Math","max","cdims","Array","cShapeMatMul","calcMatMulShape","undefined","i","aLen","bLen","a","b","indices","shapeOrigin","dimOffset","indicesOrigin","slice","dimLen","op","shape","calcShape","size","ShapeUtil","c","data","constructor","rest","j","floor","indicesA","index","indicesB","set","concat","get","finalShape","inputRank","finalRank","arrayCopyHelper","target","source","targetIndex","sourceIndex","blockSize","Error","offset","TypeUtil","typesArray","baseType","dimsArray","baseDims","baseRank","dims","TypeError","RangeError","n","Number","isInteger","getSizeFromDimensionRange","axis","start","end","stride","rank","strides","reverse","tensorRank","axisToIncrementOn","k","originalDims","shapeHints","nDims","reshapedDims","unknownDimension","originalTensorFlattenedSize","perm","map","v","pad","shape1","shape2","every","pick","picked","remnants","push","TypedArrayUtil","type","Uint8Array","Int32Array","Float32Array","binaryOp","x","y","opLambda","resultType","cast","result","calc","rType","Tensor","input0","inputShape","concatAxisSize","outputShape","dataN","dataNShape","axisIndex","output","createTypedArray","Y","axisPitch","outputBase","inputIndex","dataNDims","inputAxisPitch","inputData","inputSize","outputOffset","softmax","inputDimensions","axisCorrected","getActualAxisFromNegativeValue","N","sizeToDimension","D","sizeFromDimension","X","MIN_VALUE","scale","value","exp","transpose","inputDims","finalPerm","outputDims","inpDim","zeros","numAxesInPrefix","suffixBlocksize","prefixBlocksize","isSuffix","inpAxis","numAxes","targetDims","numBlocks","fill","startTargetIndex","sourceOffset","computeOffset","incrementIndex","doTransposeEltWise","numElementsInBlock","startSourceIndex","doTranspose","as1D","t","reshape","scalar","dtype","validateDims","linspace","stop","num","increments","range","step","abs","ceil","sigmoid","input","unaryOps","add","t1","t2","e1","e2","mul","div","tensors","typeCheckRequired","types","forEach","validateSameTypes","concatImpl","stack","shapes","validateEqualDims","expanded","expandDims","gather","newDims","indicesData","dimsStrides","computeStrides","newDimsStrides","newLogicalIndex","offsetToIndices","oldLogicalIndex","oldOffset","indicesToOffset","begin","newDimsStride","oldDimsStride","idx","tile","reps","transposeImpl","changedShapeLength","changedShape","iter","greaterEqual","where","condition","areEqual","outputData","conditionData","conditionDims","t1Dims","from","calculateReshapedDims","reshapeImpl","argMax","splitDimsIntoTwo","reduceDims","resultDims","keepDims","adjustedResultDims","origDims","ops","ort","YOLO_ANCHORS","Yolo","session","model","this","InferenceSession","create","default","img","inputTensor","preprocess","feeds","image","run","results","originalOutput","grid","outputTensor","postprocess","bboxes","console","log","imageData","width","height","dataTensor","dataProcessedTensor","assign","numClasses","yolo_head","boxXy","boxWh","boxConfidence","boxClassProbs","allBoxes","yolo_boxes_to_corners","yolo_filter_boxes","outputBoxes","scores","classes","yolo","imageDims","boxes","Promise","all","preKeepBoxesArr","scoresArr","non_max_suppression","keepIndx","boxesArr","keepScores","classesIndxArr","classIndx","classProb","className","classNames","top","left","bottom","right","resultObj","min","threshold","boxScores","boxClasses","boxClassScores","predictionMask","allIndices","negIndices","two","boxMins","boxMaxes","iouThreshold","zipped","sortedBoxes","sort","selectedBoxes","box","box_iou","e","feats","anchors","numAnchors","anchorsArray","convDims","convDims0","convDims1","convHeightIndex","convWidthIndex","convIndex","convDimsTensor","dim","softmaxImpl","w","h","box_intersection","box_union","VideoLoader","video","canvas","ctx","getContext","fps","currentTime","onseeked","canvasHeight","canvasWidth","videoHeight","videoWidth","multiplier","offset_x","offset_y","clearRect","drawImage","imgData","getImageData","bbox","font","fillStyle","fillText","beginPath","lineWidth","strokeStyle","rect","stroke","ontimeupdate","App","videoRef","useRef","canvasRef","useEffect","current","processFrames","ref","src","controls","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"iKAAA,OAAe,cAA0B,2C,gCCAzC,OAAe,cAA0B,yC,4JCCnCA,EAAUC,EAAQ,IAETC,EAAb,8FAQE,SAAiBC,EAA8BC,GAAqE,IAAvCC,EAAsC,wDAC3GC,EAAQH,EAAMI,OACdC,EAAQJ,EAAMG,OACdE,EAAQC,KAAKC,IAAIR,EAAMI,OAAQH,EAAMG,QACrCK,EAAQ,IAAIC,MAAcJ,GAGhC,GAAIJ,EAAU,CACZ,GAAIC,EAAQ,GAAKE,EAAQ,EACvB,OAEF,IAAMM,EACFZ,EAAca,gBAAgB,CAACZ,EAAMG,EAAQ,GAAIH,EAAMG,EAAQ,IAAK,CAACF,EAAMI,EAAQ,GAAIJ,EAAMI,EAAQ,KACzG,QAAqBQ,IAAjBF,EACF,OAPU,kBAS2BA,EAT3B,GASXF,EAAMH,EAAQ,GATH,KASOG,EAAMH,EAAQ,GATrB,KAYd,IAAK,IAAIQ,EAAIZ,EAAW,EAAI,EAAGY,GAAKR,EAAOQ,IAAK,CAC9C,IAAMC,EAAOZ,EAAQW,EAAI,EAAI,EAAId,EAAMG,EAAQW,GACzCE,EAAOX,EAAQS,EAAI,EAAI,EAAIb,EAAMI,EAAQS,GAE/C,GAAIC,IAASC,GAAQD,EAAO,GAAKC,EAAO,EACtC,OAEFP,EAAMH,EAAQQ,GAAKP,KAAKC,IAAIO,EAAMC,GAGpC,OAAOP,IArCX,6BA8CE,SAAuBQ,EAAqBC,GAC1C,OAAQD,EAAE,KAAOC,EAAE,QAAML,EAAY,CAACI,EAAE,GAAIC,EAAE,MA/ClD,mBA2DE,SAAaC,EAAmBC,GAO9B,IAPkF,IAA7BlB,EAA4B,wDAI3EmB,EAAYF,EAAQf,OAASgB,EAAYhB,OACzCkB,EAAgBH,EAAQI,MAAMF,GAC9BG,EAAStB,EAAWoB,EAAclB,OAAS,EAAIkB,EAAclB,OAC1DU,EAAI,EAAGA,EAAIU,EAAQV,IAC1BQ,EAAcR,GAAKK,EAAQE,EAAYP,GAAKM,EAAYN,GAE1D,OAAOQ,IArEX,kBA+EE,SAAYL,EAAQC,EAAQO,GAC1B,IAAMC,EAAQ3B,EAAc4B,UAAUV,EAAES,MAAOR,EAAEQ,OACjD,GAAIA,EAAO,CAUT,IATA,IAAME,EAAOC,EAAUD,KAAKF,GACtBI,EAAIjC,EACN,IACIoB,EAAEc,KAAKC,YAEiDJ,GAC5DF,GAEEP,EAAU,IAAIT,MAAcgB,EAAMtB,QAC/BU,EAAI,EAAGA,EAAIc,EAAMd,IAAK,CAG7B,IADA,IAAImB,EAAOnB,EACFoB,EAAIR,EAAMtB,OAAS,EAAG8B,GAAK,EAAGA,IACrCf,EAAQe,GAAKD,EAAOP,EAAMQ,GAC1BD,EAAO1B,KAAK4B,MAAMF,EAAOP,EAAMQ,IAIjC,IAAME,EAAWrC,EAAcsC,MAAMlB,EAASF,EAAES,OAC1CY,EAAWvC,EAAcsC,MAAMlB,EAASD,EAAEQ,OAGhDI,EAAES,IAAF,MAAAT,EAAC,YAAQX,EAAQqB,OAAOf,EAAGR,EAAEwB,IAAF,MAAAxB,EAAC,YAAQmB,IAAWlB,EAAEuB,IAAF,MAAAvB,EAAC,YAAQoB,QAG1D,OAAOR,KA3Gb,8BAsHE,SAAwBJ,EAA8BgB,GAEpD,IAAMC,EAAYjB,EAAMtB,OAClBwC,EAAYF,EAAWtC,OAC7B,GAAIuC,EAAYC,EACd,OAAO,EAET,IAAK,IAAI9B,EAAI,EAAGA,GAAK6B,EAAW7B,IAC9B,GAA6B,IAAzBY,EAAMiB,EAAY7B,IAAYY,EAAMiB,EAAY7B,KAAO4B,EAAWE,EAAY9B,GAChF,OAAO,EAGX,OAAO,MAlIX,KAuIO,SAAS+B,EACZC,EAAwBC,EAAwBC,EAAqBC,EACrEC,GACF,GAAID,EAAc,GAAKA,GAAeF,EAAO3C,OAC3C,MAAM,IAAI+C,MAAJ,6BAER,GAAIH,EAAc,GAAKA,GAAeF,EAAO1C,OAC3C,MAAM,IAAI+C,MAAJ,6BAER,GAAIF,EAAcC,EAAYH,EAAO3C,OACnC,MAAM,IAAI+C,MAAJ,kDAER,GAAIH,EAAcE,EAAYJ,EAAO1C,OACnC,MAAM,IAAI+C,MAAJ,4CAGR,IAAK,IAAIC,EAAS,EAAGA,EAASF,EAAWE,IACvCN,EAAOE,EAAcI,GAAUL,EAAOE,EAAcG,GAIjD,IAAMC,EAAb,sGACE,SAAyBC,GACvB,GAAIA,EAAWlD,OAAS,EACtB,MAAM,IAAI+C,MAAM,oDAGlB,IADA,IAAMI,EAAWD,EAAW,GACnBxC,EAAI,EAAGA,EAAIwC,EAAWlD,SAAUU,EACvC,GAAIwC,EAAWxC,KAAOyC,EACpB,MAAM,IAAIJ,MAAM,wBARxB,KAcatB,EAAb,sGACE,SAAyB2B,GACvB,GAAIA,EAAUpD,OAAS,EACrB,MAAM,IAAI+C,MAAM,qDAIlB,IAFA,IAAMM,EAAWD,EAAU,GACrBE,EAAWD,EAASrD,OACjBU,EAAI,EAAGA,EAAI0C,EAAUpD,SAAUU,EAAG,CACzC,IAAM6C,EAAOH,EAAU1C,GACvB,GAAI6C,EAAKvD,SAAWsD,EAClB,MAAM,IAAIP,MAAM,8CAElB,IAAK,IAAIjB,EAAI,EAAGA,EAAIwB,IAAYxB,EAC9B,GAAIuB,EAASvB,KAAOyB,EAAKzB,GACvB,MAAM,IAAIiB,MAAM,oCAd1B,0BAoBE,SAAoBQ,GAClB,GAAIA,EAAKvD,OAAS,GAAKuD,EAAKvD,OAAS,EACnC,MAAM,IAAIwD,UAAJ,mDAGR,GAAoB,IAAhBD,EAAKvD,OACP,MAAM,IAAIyD,WAAW,wCANwB,oBAS/BF,GAT+B,IAS/C,2BAAsB,CAAC,IAAZG,EAAW,QACpB,IAAKC,OAAOC,UAAUF,GACpB,MAAM,IAAIF,UAAJ,yBAAgCE,EAAhC,uBAER,GAAIA,GAAK,GAAKA,EAAI,WAChB,MAAM,IAAIF,UAAJ,gCAAuCE,EAAvC,qBAdqC,iCApBnD,kBAuCE,SAAYH,GACV,OAAO9B,EAAUoC,0BAA0BN,EAAM,EAAGA,EAAKvD,UAxC7D,+BA2CE,SAAyBuD,EAA6BO,GACpD,GAAIA,EAAOP,EAAKvD,OACd,MAAM,IAAI+C,MAAJ,+BAAkCe,EAAlC,gDAA8EP,EAAKvD,OAAnF,iBAGR,OAAOyB,EAAUoC,0BAA0BN,EAAMO,EAAMP,EAAKvD,UAhDhE,6BAmDE,SAAuBuD,EAA6BO,GAClD,GAAIA,EAAOP,EAAKvD,OACd,MAAM,IAAI+C,MAAJ,+BAAkCe,EAAlC,8CAA4EP,EAAKvD,OAAjF,iBAGR,OAAOyB,EAAUoC,0BAA0BN,EAAM,EAAGO,KAxDxD,uCA2DE,SAAiCP,EAA6BQ,EAAeC,GAE3E,IADA,IAAIxC,EAAO,EACFd,EAAIqD,EAAOrD,EAAIsD,EAAKtD,IAAK,CAGhC,GAAI6C,EAAK7C,IAAM,EACb,MAAM,IAAIqC,MAAJ,sHAIRvB,GAAQ+B,EAAK7C,GAEf,OAAOc,IAvEX,2BAkFE,SAAqBS,EAAiBgC,EAAkBH,QACzCrD,IAATqD,IACFA,EAAO7B,EAAMjC,QAGf,IADA,IAAIgD,EAAS,EACJtC,EAAI,EAAGA,EAAIoD,IAAQpD,EAC1BsC,GAAWf,EAAMvB,GAAKuD,EAAOvD,GAE/B,OAAOsC,IA1FX,4BA4FE,SAAsB1B,GACpB,IAAM4C,EAAO5C,EAAMtB,OACnB,GAAIkE,EAAO,EACT,MAAO,CAAC,GAGV,IAAMC,EAAU,IAAI7D,MAAM4D,GAC1BC,EAAQD,EAAO,GAAK,EACpBC,EAAQD,EAAO,GAAK5C,EAAM4C,EAAO,GACjC,IAAK,IAAIxD,EAAIwD,EAAO,EAAGxD,GAAK,IAAKA,EAC/ByD,EAAQzD,GAAKyD,EAAQzD,EAAI,GAAKY,EAAMZ,EAAI,GAE1C,OAAOyD,IAxGX,uBA0GE,SAAiBZ,GACf,OAAOA,EAAKa,YA3GhB,6BA6GE,SAAuBrD,EAAmBoD,GAExC,GAAa,IADAA,EAAQnE,OAEnB,OAAO,EAGT,IADA,IAAIiC,EAAQlB,EAAQA,EAAQf,OAAS,GAC5BU,EAAI,EAAGA,EAAIK,EAAQf,OAAS,IAAKU,EACxCuB,GAASkC,EAAQzD,GAAKK,EAAQL,GAEhC,OAAOuB,IAtHX,6BAyHE,SAAuBe,EAAgBmB,GACrC,IAAMD,EAAOC,EAAQnE,OACrB,GAAa,IAATkE,EACF,MAAO,GACF,GAAa,IAATA,EACT,MAAO,CAAClB,GAGV,IADA,IAAMjC,EAAoB,IAAIT,MAAM6D,EAAQnE,QACnCU,EAAI,EAAGA,EAAIK,EAAQf,OAAS,IAAKU,EACxCK,EAAQL,GAAKP,KAAK4B,MAAMiB,EAASmB,EAAQzD,IACzCsC,GAAUjC,EAAQL,GAAKyD,EAAQzD,GAGjC,OADAK,EAAQA,EAAQf,OAAS,GAAKgD,EACvBjC,IAtIX,4CAwIE,SAAsC+C,EAAcO,GAClD,GAAIP,GAAQO,GAAcP,GAAQO,EAAa,EAC7C,MAAM,IAAItB,MAAM,wCAElB,OAAOe,EAAO,EAAIA,EAAOO,EAAaP,IA5I1C,4BAuJE,SAAsB7B,EAAiBsB,EAAgBe,QAC3B7D,IAAtB6D,IACFA,EAAoBf,EAAKvD,QAG3B,IAAK,IAAIuE,EAAID,EAAoB,EAAGC,GAAK,IACvCtC,EAAMsC,OACFtC,EAAMsC,GAAKhB,EAAKgB,OAFwBA,EAK5CtC,EAAMsC,GAAK,IAjKjB,mCAiLA,SAA6BC,EAAqCC,GAMhE,IALA,IAAMC,EAAQD,EAAWzE,OACnB2E,EAAe,IAAIrE,MAAcoE,GACnCE,GAAoB,EACpBpD,EAAO,EAEFd,EAAI,EAAGA,EAAIgE,EAAOhE,IAAK,CAC9B,GAAI+D,EAAW/D,IAAM,EACnB,MAAM,IAAIqC,MAAM,sCAElB,IAAuB,IAAnB0B,EAAW/D,GAAW,CACxB,IAA0B,IAAtBkE,EACF,MAAM,IAAI7B,MAAM,mCAElB6B,EAAmBlE,MACd,CACL,GAAsB,IAAlB+D,EAAW/D,GAAU,CACvB,GAAIA,GAAK8D,EAAaxE,OACpB,MAAM,IAAI+C,MAAM,gFAElB4B,EAAajE,GAAK8D,EAAa9D,QAE/BiE,EAAajE,GAAK+D,EAAW/D,GAE/Bc,GAAQmD,EAAajE,IAIzB,IAA0B,IAAtBkE,EAAyB,CAC3B,IAAMC,EAA8BpD,EAAUD,KAAKgD,GACnD,GAAIK,EAA8BrD,IAAS,EACzC,MAAM,IAAIuB,MAAJ,oFACFyB,EADE,4BAC8BC,EAD9B,MAGRE,EAAaC,GAAoBC,EAA8BrD,EAEjE,OAAOmD,IArNT,6BA8NA,SAAuB9D,EAA0BiE,GAC7C,OAAIA,EACKA,EAAKC,KAAI,SAACC,GAAD,OAAOnE,EAAEmE,MAElBnE,EAAEM,QAAQiD,YAlOvB,sBA2OA,SAAgBb,EAA6B0B,GAC3C,IAAMf,EAAOX,EAAKvD,OAClB,OAAOuD,EAAKwB,KAAI,SAACC,EAAGtE,GAAJ,OAAUsE,EAAIC,EAAIvE,GAAKuE,EAAIvE,EAAIwD,QA7OjD,sBAqPA,SAAgBgB,EAA+BC,GAC7C,OAAID,EAAOlF,SAAWmF,EAAOnF,QAGtBkF,EAAOE,OAAM,SAACJ,EAAGtE,GAAJ,OAAUsE,IAAMG,EAAOzE,QAzP7C,8BAkQA,SAAwB6C,EAA6B8B,GAInD,IAHA,IAAMC,EAAmB,GACnBC,EAAqB,GAEnB7E,EAAI,EAAGA,EAAI6C,EAAKvD,SAAUU,EAC7BA,IAAM2E,EACPC,EAAOE,KAAKjC,EAAK7C,IAEjB6E,EAASC,KAAKjC,EAAK7C,IAIvB,MAAO,CAAC4E,EAAQC,OA9QlB,KAmRWE,EAAb,qGACE,SAAwBC,EAAclE,GAClC,OAAQkE,GACJ,IAAK,OACL,OAAO,IAAIC,WAAWnE,GACtB,IAAK,QACL,OAAO,IAAIoE,WAAWpE,GACtB,IAAK,UACL,OAAO,IAAIqE,aAAarE,GACxB,QACA,MAAM,IAAIuB,MAAM,yBAV1B,KC3bA,IAAMtD,EAAUC,EAAQ,IAEjB,SAASoG,EACdC,EAAWC,EAAWC,EAA8CC,GAC/C,SAAfA,IACFH,EAAII,EAAKJ,EAAG,QACZC,EAAIG,EAAKH,EAAG,SAEd,IAAMI,EACFzG,EAAc0G,KAAK5G,EAAQsG,EAAEpE,KACFoE,EAAExC,KAAOwC,EAAExC,KAAKpC,MAAM,GAAK,CAAC4E,EAAEpE,KAAK3B,SAC3CP,EAAQuG,EAAErE,KACFqE,EAAEzC,KAAOyC,EAAEzC,KAAKpC,MAAM,GAAK,CAAC6E,EAAErE,KAAK3B,SAAUiG,GAC5E,IAAKG,EACH,MAAM,IAAIrD,MAAM,qBAElB,IAAMuD,EAAQJ,GAA0BH,EAAEL,KAE1C,OADe,IAAIa,SAAOD,EAAOF,EAAOzE,KAAMyE,EAAO9E,OClBlD,SAASc,EAAO2D,EAAajC,GAClC,IAAM0C,EAAST,EAAE,GACXU,EAAaD,EAAOjD,KAAOiD,EAAOjD,KAAO,CAACiD,EAAO7E,KAAK3B,QAE5D,GAAI8D,GAAQ2C,EAAWzG,QAAU8D,GAAS,EAAI2C,EAAWzG,OACvD,MAAM,IAAI+C,MAAJ,gEAGJe,EAAO,IACTA,EAAO2C,EAAWzG,OAAS8D,GAQ7B,IAHA,IAAI4C,EAAiBD,EAAW3C,GAC1B6C,EAAc,IAAIrG,MAAcmG,EAAWzG,QAExCU,EAAI,EAAGA,EAAIqF,EAAE/F,OAAQU,IAI5B,IAHA,IAAMkG,EAAQb,EAAErF,GACVmG,EAAaD,EAAMrD,KAAOqD,EAAMrD,KAAO,CAACqD,EAAMjF,KAAK3B,QAEhD8G,EAAY,EAAGA,EAAYL,EAAWzG,OAAQ8G,IAAa,CAOlE,GALIA,IAAchD,IAChB4C,GAAkBG,EAAWC,IAI3BL,EAAWK,KAAeD,EAAWC,GACvC,MAAM,IAAI/D,MAAJ,oCAIR4D,EAAYG,GAAaD,EAAWC,GAKxCH,EAAY7C,GAAQ4C,EAUpB,IANA,IAAMK,EAAS,IAAIR,SAAOC,EAAOd,KAAMD,EAAeuB,iBAAiBjB,EAAE,GAAGL,KAAMjE,EAAUD,KAAKmF,IAAeA,GAC1GM,EAAIF,EAAOpF,KAIbuF,EAAY,EACPxG,EAAIiG,EAAY3G,OAAS,EAAGU,GAAKoD,EAAMpD,IAC9CwG,GAAaP,EAAYjG,GAI3B,IADA,IAAIyG,EAAa,EACRC,EAAa,EAAGA,EAAarB,EAAE/F,OAAQoH,IAAc,CAO5D,IANA,IAAMR,EAAQb,EAAEqB,GACVC,EAAYT,EAAMrD,KAAOqD,EAAMrD,KAAO,CAACqD,EAAMjF,KAAK3B,QAIpDsH,EAAiB,EACZ5G,EAAI2G,EAAUrH,OAAS,EAAGU,GAAKoD,EAAMpD,IAC5C4G,GAAkBD,EAAU3G,GAY9B,IATA,IAAM6G,EAAYX,EAAMjF,KAClB6F,EAAY/F,EAAUD,KAAK6F,GAM7BI,EAAeN,EAEVzG,EAAI,EAAGoB,EAAI,EAAGpB,EAAI8G,EAAW9G,IACpCuG,EAAEQ,EAAe/G,GAAK6G,EAAU7G,KAC1BoB,IAAMwF,IAEVG,GAAiBP,EAAYI,EAC7BxF,EAAI,GAGRqF,GAAcG,EAGhB,OAAOP,ECpFF,SAASW,EAAQ3B,EAAWjC,GAYjC,IAXA,IAAM6D,EAAkB5B,EAAExC,KAAOwC,EAAExC,KAAO,CAACwC,EAAEpE,KAAK3B,QAC5CuC,EAAYoF,EAAgB3H,OAE5B4H,EAAgBnG,EAAUoG,+BAA+B/D,EAAMvB,GAC/DuF,EAAIrG,EAAUsG,gBAAgBJ,EAAiBC,GAC/CI,EAAIvG,EAAUwG,kBAAkBN,EAAiBC,GAEjDM,EAAInC,EAAEpE,KAENsF,EAAIxB,EAAeuB,iBAAiBjB,EAAEL,KAAMK,EAAEpE,KAAK3B,QAEhDU,EAAI,EAAGA,EAAIoH,EAAGpH,IAAK,CAM1B,IAJA,IAAMsC,EAAStC,EAAIsH,EAGf5H,EAAMuD,OAAOwE,UACRrG,EAAI,EAAGA,EAAIkG,EAAGlG,IACjBoG,EAAElF,EAASlB,GAAK1B,IAClBA,EAAM8H,EAAElF,EAASlB,IAMrB,IADA,IAAIsG,EAAQ,EACHtG,EAAI,EAAGA,EAAIkG,EAAGlG,IAAK,CAC1B,IAAMuG,EAAQH,EAAElF,EAASlB,GAAK1B,EAC9B6G,EAAEjE,EAASlB,GAAK3B,KAAKmI,IAAID,GACzBD,GAASjI,KAAKmI,IAAID,GAIpB,IAAK,IAAIvG,EAAI,EAAGA,EAAIkG,EAAGlG,IACP,IAAVsG,EACFnB,EAAEjE,EAASlB,GAAK,EAEhBmF,EAAEjE,EAASlB,IAAMsG,EAKvB,OAAO,IAAI7B,SAAOR,EAAEL,KAAMuB,EAAGU,GCxCxB,SAASY,EAAUxC,EAAWjB,GACnC,IAAM0D,EAAYzC,EAAExC,KAAOwC,EAAExC,KAAO,CAACwC,EAAEpE,KAAK3B,QACtCkE,EAAOsE,EAAUxI,OAKnByI,EAAY,IAAInI,MAAc4D,GAClC,GAAIY,GAAQA,EAAK9E,SAAWkE,EAC1BuE,EAAY3D,OAEZ,IAAK,IAAIpE,EAAI,EAAGA,EAAIwD,EAAMxD,IACxB+H,EAAU/H,GAAKwD,EAAOxD,EAAI,EAU9B,IANA,IAAMgI,EAAa,IAAIpI,MAAc4D,GAC/BD,EAAS,IAAI3D,MAAc4D,GAKxBxD,EAAI,EAAGA,EAAIwD,EAAMxD,IAAK,CAC7B,IAAMiI,EAASF,EAAU/H,GACzBgI,EAAWhI,GAAK8H,EAAUG,GAExB1E,EAAOvD,GADLiI,EAAS,EAAIzE,EACHzC,EAAUwG,kBAAkBO,EAAWG,EAAS,GAEhD,EAehB,IAXA,IAAM5B,EAAS6B,EAAMF,EAAY3C,EAAEL,MAE7BwC,EAAInC,EAAEpE,KACNsF,EAAIF,EAAOpF,KAIbkH,EAAkB,EAClBC,EAAkB,EAClBC,EAAkB,EAClBC,GAAW,EACNtI,EAAIwD,EAAO,EAAGxD,GAAK,IAAKA,EAAG,CAClC,IAAMuI,EAAUR,EAAU/H,GACtBsI,GAAaC,IAAYvI,EAC3BoI,GAAmBN,EAAUS,IAE7BD,GAAW,EACXD,GAAmBP,EAAUS,KAC3BJ,GAYN,OARwB,IAApBE,EAmDJtG,EAlD0CwE,EAAGiB,EAkDb,EAAG,EAlDVY,GACM,IAApBA,EA+Bb,SACII,EAAiBC,EAAsBC,EAAmBnF,EAAkBvB,EAC5EC,GAKF,IAJA,IAAMC,EAAc,IAAItC,MAAc4I,GAASG,KAAK,GAEhDC,EAAmB,EAEd5I,EAAI,EAAGA,EAAI0I,IAAa1I,EAAG,CAClC,IAAM6I,EAAe9H,EAAU+H,cAAc5G,EAAaqB,EAAQiF,GAClExG,EAAO4G,KAAsB3G,EAAO4G,GACpC9H,EAAUgI,eAAe7G,EAAauG,EAAYD,IAxClDQ,CAAmBb,EAAiBH,EAAYK,EAAiB9E,EAAQgD,EAAGiB,GAUhF,SACIgB,EAAiBC,EAAsBC,EAAmBO,EAA4B1F,EACtFvB,EAAwBC,GAM1B,IALA,IAAMC,EAAc,IAAItC,MAAc4I,GAASG,KAAK,GAE9CO,EAAmB,EACrBN,EAAmB,EAEd5I,EAAI,EAAGA,EAAI0I,IAAa1I,EAAG,CAElC+B,EAAgBC,EAAQC,EAAQ2G,EAAkBM,EAD/BnI,EAAU+H,cAAc5G,EAAaqB,EAAQiF,GACiBS,GAEjFlI,EAAUgI,eAAe7G,EAAauG,EAAYD,GAClDI,GAAoBK,GArBpBE,CAAYhB,EAAiBH,EAAYK,EAAiBD,EAAiB7E,EAAQgD,EAAGiB,GAGjFnB,ECpDF,SAAS+C,EAAKC,GACnB,OAAOC,EAAQD,EAAG,CAACA,EAAEpI,KAAK3B,SAGrB,SAASiK,EAAO5B,GAAuD,IAAxC6B,EAAuC,uDAAnB,UACxD,GAAc,YAAVA,GAAiC,UAAVA,EACvB,MAAM,IAAInH,MAAM,4CAEpB,IAAMpB,EAAO8D,EAAeuB,iBAAiBkD,EAAO,GAEpD,OADAvI,EAAK,GAAK0G,EACH,IAAI9B,SAAO2D,EAAOvI,EAAM,CAAC,IAG3B,SAASiH,EAAMrF,GAAqE,IAAxC2G,EAAuC,uDAAnB,UACrE,GAAc,YAAVA,GAAiC,UAAVA,GAA+B,SAAVA,EAC5C,MAAM,IAAInH,MAAM,iDAGpB,OADAtB,EAAU0I,aAAa5G,GAChB,IAAIgD,SAAO2D,EAAOzE,EAAeuB,iBAAiBkD,EAAOzI,EAAUD,KAAK+B,IAAQA,GAGlF,SAAS6G,EAASrG,EAAesG,EAAcC,GACpD,GAAY,IAARA,EACF,MAAM,IAAIvH,MAAM,mCAElB,IAAMwH,GAAcF,EAAOtG,IAAUuG,EAAM,GACrC3I,EAAO8D,EAAeuB,iBAAiB,UAAWsD,GACxD3I,EAAK,GAAKoC,EACV,IAAK,IAAIrD,EAAI,EAAGA,EAAIiB,EAAK3B,OAAQU,IAC/BiB,EAAKjB,GAAKiB,EAAKjB,EAAI,GAAK6J,EAE1B,OAAO,IAAIhE,SAAO,UAAW5E,EAAM,CAAC2I,IAG/B,SAASE,EAAMzG,EAAesG,GAAgE,IAAlDI,EAAiD,uDAA1C,EAAGP,EAAuC,uDAAnB,UAC/E,GAAa,IAATO,EACF,MAAM,IAAI1H,MAAM,oCAOlB,GAJIsH,EAAOI,GAAiB,IAATA,IACjBA,GAAQ,GAGN1G,IAAU0G,GAAS1G,EAAQsG,GAAQI,EAAO,GAAOJ,EAAOtG,GAAS0G,EAAO,EAC1E,OAAO,IAAIlE,SAAO2D,EAAOzE,EAAeuB,iBAAiBkD,EAAO,GAAI,CAAC,IAEvE,IAAM1I,EAAOrB,KAAKuK,IAAIvK,KAAKwK,MAAMN,EAAOtG,GAAS0G,IAC3C9I,EAAO8D,EAAeuB,iBAAiBkD,EAAO1I,GACpDG,EAAK,GAAKoC,EACV,IAAK,IAAIrD,EAAI,EAAGA,EAAIiB,EAAK3B,OAAQU,IAC/BiB,EAAKjB,GAAKiB,EAAKjB,EAAI,GAAK+J,EAE1B,OAAO,IAAIlE,SAAO2D,EAAOvI,EAAM,CAACH,IAI3B,SAASoJ,EAAQb,GACtB,GAAe,YAAXA,EAAErE,MAAiC,UAAXqE,EAAErE,KAC5B,MAAM,IAAI3C,MAAM,kCAElB,OCzEK,SAAiB8H,GAGtB,IAFA,IAAM3C,EAAI2C,EAAMlJ,KACVsF,EAAIxB,EAAeuB,iBAAiB6D,EAAMnF,KAAMwC,EAAElI,QAC/CU,EAAI,EAAGA,EAAIwH,EAAElI,OAAQU,IAC5BuG,EAAEvG,GAAM,GAAK,EAAIP,KAAKmI,KAAKJ,EAAExH,KAE/B,OAAO,IAAI6F,SAAOsE,EAAMnF,KAAMuB,EAAG4D,EAAMtH,KAAOsH,EAAMtH,KAAO,CAACsH,EAAMlJ,KAAK3B,SDmEhE8K,CAAiBf,GAGnB,SAASzB,EAAIyB,GAClB,GAAe,YAAXA,EAAErE,MAAiC,UAAXqE,EAAErE,KAC5B,MAAM,IAAI3C,MAAM,kCAElB,OCvEK,SAAa8H,GAClB,GAAkB,WAAfA,EAAMnF,KACP,MAAM,IAAI3C,MAAM,kCAIlB,IAFA,IAAMmF,EAAI2C,EAAMlJ,KACVsF,EAAIxB,EAAeuB,iBAAiB6D,EAAMnF,KAAMwC,EAAElI,QAC/CU,EAAI,EAAGA,EAAIwH,EAAElI,OAAQU,IAC5BuG,EAAEvG,GAAKP,KAAKmI,IAAIJ,EAAExH,IAEpB,OAAO,IAAI6F,SAAOsE,EAAMnF,KAAMuB,EAAG4D,EAAMtH,KAAOsH,EAAMtH,KAAO,CAACsH,EAAMlJ,KAAK3B,SD8DhE8K,CAAaf,GAIf,SAASgB,EAAIC,EAAYC,GAC9B,GAAiB,YAAZD,EAAGtF,MAAkC,UAAZsF,EAAGtF,MAAkC,YAAZuF,EAAGvF,MAAkC,UAAZuF,EAAGvF,KACjF,MAAM,IAAI3C,MAAM,kCAElB,GAAIiI,EAAGtF,OAASuF,EAAGvF,KACjB,MAAM,IAAI3C,MAAM,6BAElB,OAAO+C,EAASkF,EAAIC,GAAI,SAACC,EAAIC,GAAL,OAAaD,EAAKC,IAAKH,EAAGtF,MAa7C,SAAS0F,EAAIJ,EAAYC,GAC9B,GAAiB,YAAZD,EAAGtF,MAAkC,UAAZsF,EAAGtF,MAAkC,YAAZuF,EAAGvF,MAAkC,UAAZuF,EAAGvF,KACjF,MAAM,IAAI3C,MAAM,kCAElB,GAAIiI,EAAGtF,OAASuF,EAAGvF,KACjB,MAAM,IAAI3C,MAAM,6BAElB,OAAO+C,EAASkF,EAAIC,GAAI,SAACC,EAAIC,GAAL,OAAaD,EAAKC,IAAKH,EAAGtF,MAG7C,SAAS2F,EAAIL,EAAYC,GAC9B,GAAiB,YAAZD,EAAGtF,MAAkC,UAAZsF,EAAGtF,MAAkC,YAAZuF,EAAGvF,MAAkC,UAAZuF,EAAGvF,KACjF,MAAM,IAAI3C,MAAM,kCAElB,GAAIiI,EAAGtF,OAASuF,EAAGvF,KACjB,MAAM,IAAI3C,MAAM,6BAGlB,OAAO+C,EAASkF,EAAIC,GAAI,SAACC,EAAIC,GAAL,OAAaD,EAAKC,IAAKH,EAAGtF,MAY7C,SAAStD,EAAOkJ,GAAgE,IAA7CxH,EAA4C,uDAArC,EAAGyH,IAAkC,yDACpF,GAAID,EAAQtL,OAAS,EACnB,MAAM,IAAI+C,MAAM,8CAGlB,GAAGwI,EAAmB,CACpB,IAAMC,EAAgB,GACtBF,EAAQG,SAAQ,SAAA1B,GACdyB,EAAMhG,KAAKuE,EAAErE,SAEfzC,EAASyI,kBAAkBF,GAG7B,OAAOG,EAAWL,EAASxH,GAGtB,SAAS8H,EAAMN,GAAsC,IAAnBxH,EAAkB,uDAAX,EAC9C,GAAIwH,EAAQtL,OAAS,EACnB,MAAM,IAAI+C,MAAM,wCAGlB,IAAMyI,EAAgB,GAChBK,EAAuC,GAC7CP,EAAQG,SAAQ,SAAA1B,GACdyB,EAAMhG,KAAKuE,EAAErE,MACbmG,EAAOrG,KAAKuE,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,YAExCiD,EAASyI,kBAAkBF,GAC3B/J,EAAUqK,kBAAkBD,GAC5B,IAAM3H,EAAOoH,EAAQ,GAAG/H,KAAO+H,EAAQ,GAAG/H,KAAKvD,OAAS,EACxD8D,EAAOrC,EAAUoG,+BAA+B/D,EAAMI,GACtD,IAAM6H,EAAWT,EAAQvG,KAAI,SAAAgF,GAAC,OAAIiC,EAAWjC,EAAGjG,MAChD,OAAO1B,EAAO2J,EAAUjI,GAAM,GAGzB,SAASmI,EAAOlC,EAAWhJ,GAAmC,IAAlB+C,EAAiB,uDAAV,EACxD,GAAc,WAAXiG,EAAErE,KACH,MAAM,IAAI3C,MAAM,2CAElB,GAAoB,UAAjBhC,EAAQ2E,MAAqB3E,EAAQwC,MAAQxC,EAAQwC,KAAKvD,OAAS,EACpE,MAAM,IAAI+C,MAAM,0CAElB,IAAMQ,EAAOwG,EAAExG,KAAOwG,EAAExG,KAAKpC,QAAU,CAAC4I,EAAEpI,KAAK3B,QACzCkM,EAAU3I,EACV4I,EAAcpL,EAAQY,KAC5BuK,EAAQpI,GAAQqI,EAAYnM,OAK5B,IAJA,IAAMoM,EAAc3K,EAAU4K,eAAe9I,GACvC+I,EAAiB7K,EAAU4K,eAAeH,GAC1CjF,EAAIxB,EAAeuB,iBAAiB+C,EAAErE,KAAMjE,EAAUD,KAAK0K,IAC3DhE,EAAI6B,EAAEpI,KACHjB,EAAI,EAAGA,EAAIuG,EAAEjH,SAAUU,EAAG,CACjC,IAAM6L,EAAkB9K,EAAU+K,gBAAgB9L,EAAG4L,GAC/CG,EAAkBF,EAAgBpL,QACxCsL,EAAgB3I,GAAQqI,EAAYI,EAAgBzI,IACpD,IAAM4I,EAAYjL,EAAUkL,gBAAgBF,EAAiBL,GAC7DnF,EAAEvG,GAAKwH,EAAEwE,GAEX,OAAO,IAAInG,SAAOwD,EAAErE,KAAMuB,EAAGiF,GAGxB,SAAS/K,EAAM4I,EAAW6C,EAAiBpL,GAChD,GAAc,WAAXuI,EAAErE,KACH,MAAM,IAAI3C,MAAM,2CAMlB,IAJA,IAAM8J,EAAgBpL,EAAU4K,eAAe7K,GACzCsL,EAAgBrL,EAAU4K,eAAetC,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,SACnEkI,EAAI6B,EAAEpI,KACNsF,EAAIxB,EAAeuB,iBAAiB+C,EAAErE,KAAMjE,EAAUD,KAAKA,IACxDd,EAAI,EAAGA,EAAIuG,EAAEjH,SAAUU,EAAG,CACjC,IACM+L,EADkBhL,EAAU+K,gBAAgB9L,EAAGmM,GACb9H,KAAI,SAACgI,EAASjL,GAAV,OAAoBiL,EAAMH,EAAM9K,MACtE4K,EAAYjL,EAAUkL,gBAAgBF,EAAiBK,GAC7D7F,EAAEvG,GAAKwH,EAAEwE,GAEX,OAAO,IAAInG,SAAOwD,EAAErE,KAAMuB,EAAGzF,GAGxB,SAASwL,EAAKjD,EAAWkD,GAC9B,GAAc,WAAXlD,EAAErE,KACH,MAAM,IAAI3C,MAAM,2CAElB,IAAMQ,EAAOwG,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,QACjCkE,EAAOX,EAAKvD,OACZkM,EAAU,IAAI5L,MAAM4D,GAC1B,GAAGA,IAAS+I,EAAKjN,OACf,MAAM,IAAI+C,MAAM,sDAElB,IAAK,IAAIrC,EAAI,EAAGA,EAAIwD,EAAMxD,IACxBwL,EAAQxL,GAAK6C,EAAK7C,GAAKuM,EAAKvM,GAM9B,IAJA,IAAM0L,EAAc3K,EAAU4K,eAAe9I,GACvC+I,EAAiB7K,EAAU4K,eAAeH,GAC1CjF,EAAIxB,EAAeuB,iBAAiB+C,EAAErE,KAAMjE,EAAUD,KAAK0K,IAC3DhE,EAAI6B,EAAEpI,KACHjB,EAAI,EAAGA,EAAIuG,EAAEjH,SAAUU,EAAG,CAGjC,IAFA,IAAM6L,EAAkB9K,EAAU+K,gBAAgB9L,EAAG4L,GAC/CG,EAAkB,IAAInM,MAAM4D,GACzBpC,EAAI,EAAGA,EAAIoC,IAAQpC,EAC1B2K,EAAgB3K,GAAKyK,EAAgBzK,GAAKiI,EAAExG,KAAKzB,GAEnD,IAAM4K,EAAYjL,EAAUkL,gBAAgBF,EAAiBL,GAC7DnF,EAAEvG,GAAKwH,EAAEwE,GAEX,OAAO,IAAInG,SAAOwD,EAAErE,KAAMuB,EAAGiF,GAIxB,SAAS3D,EAAUwB,EAAWjF,GACnC,OAAOoI,EAAcnD,EAAGjF,GAInB,SAASkH,EAAWjC,GAA8B,IAAnBjG,EAAkB,uDAAX,EAC3CA,EAAOrC,EAAUoG,+BAA+B/D,EAAMiG,EAAExG,KAAOwG,EAAExG,KAAKvD,OAAS,GAK/E,IAJA,IAAMuD,EAAOwG,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,QACjCmN,EAAqB5J,EAAKvD,OAAS,EACnCoN,EAAe,IAAI9M,MAAc6M,GACnCE,EAAO,EACF3M,EAAI,EAAGA,EAAIyM,IAAsBzM,EAEtC0M,EAAa1M,GADXA,IAAMoD,EACU,EAEAP,EAAK8J,KAG3B,OAAO,IAAI9G,SAAOwD,EAAErE,KAAMqE,EAAEpI,KAAMyL,GAI7B,SAASE,EAAatC,EAAYC,GACvC,GAAiB,YAAZD,EAAGtF,MAAkC,UAAZsF,EAAGtF,MAAgC,SAAZsF,EAAGtF,MACxC,YAAZuF,EAAGvF,MAAkC,UAAZuF,EAAGvF,MAAgC,SAAZuF,EAAGvF,KACrD,MAAM,IAAI3C,MAAM,kCAElB,GAAIiI,EAAGtF,OAASuF,EAAGvF,KACjB,MAAM,IAAI3C,MAAM,6BAElB,OAAO+C,EAASkF,EAAIC,GAAI,SAACC,EAAIC,GAAL,OAAaD,GAAMC,EAAK,EAAI,IAAI,QAGnD,SAASoC,EAAMC,EAAmBxC,EAAYC,GAInD,GAFAxJ,EAAUgM,SAASzC,EAAGzH,KAAOyH,EAAGzH,KAAO,CAACyH,EAAGrJ,KAAK3B,QAASiL,EAAG1H,KAAO0H,EAAG1H,KAAO,CAAC0H,EAAGtJ,KAAK3B,SACtFiD,EAASyI,kBAAkB,CAACV,EAAGtF,KAAMuF,EAAGvF,OAClB,SAAnB8H,EAAU9H,KACX,MAAM,IAAI3C,MAAM,sCAIlB,IAAM4D,EAAcqE,EAAGzH,KAAOyH,EAAGzH,KAAO,CAACyH,EAAGrJ,KAAK3B,QAC3C+G,EAAS,IAAIR,SAAOyE,EAAGtF,KAAMD,EAAeuB,iBAAiBgE,EAAGtF,KAAMjE,EAAUD,KAAKmF,IACnEA,GAClB+G,EAAa3G,EAAOpF,KAGpBgM,EAAgBH,EAAU7L,KAC1BuG,EAAI8C,EAAGrJ,KACPsF,EAAIgE,EAAGtJ,KAGb,GAAI6L,EAAUjK,MAAkC,IAA1BiK,EAAUjK,KAAKvD,OAsB9B,CAELyB,EAAUgM,SAASD,EAAUjK,KAAM0H,EAAG1H,KAAO0H,EAAG1H,KAAO,CAAC0H,EAAGtJ,KAAK3B,SAEhE,IAAI,IAAIU,EAAI,EAAGA,EAAIiN,EAAc3N,SAAUU,EACzCgN,EAAWhN,GAAKiN,EAAcjN,GAAK,EAAIwH,EAAExH,GAAKuG,EAAEvG,OA3BD,CAEjD,IAAMkN,EAAgBJ,EAAUjK,KAAOiK,EAAUjK,KAAO,CAACiK,EAAU7L,KAAK3B,QAClE6N,EAAS7C,EAAGzH,KAAOyH,EAAGzH,KAAO,CAACyH,EAAGrJ,KAAK3B,QAC5C,GAAI4N,EAAc,KAAOC,EAAO,GAC9B,MAAM,IAAI9K,MAAM,yEAGlB,IAAIC,EAAS,EAEb,GAAGgI,EAAGzH,MAAQyH,EAAGzH,KAAKvD,OAAS,EAC7B,IAAI,IAAIU,EAAI,EAAGA,EAAIsK,EAAGzH,KAAKvD,SAAUU,EACnCsC,GAAUgI,EAAGzH,KAAK7C,GAItB,IAAI,IAAIA,EAAI,EAAGA,EAAIiN,EAAc3N,SAAUU,EACzC,IAAI,IAAIoB,EAAI,EAAGA,EAAIkB,IAAUlB,EAC3B4L,EAAWhN,EAAEsC,EAASlB,GAAK6L,EAAcjN,GAAK,EAAIwH,EAAExH,EAAEsC,EAASlB,GAAKmF,EAAEvG,EAAEsC,EAASlB,GAYvF,OAAOiF,EAIF,SAASZ,EAAK4D,EAAWG,GAG9B,OAAQA,GACJ,IAAK,QACL,OAAO,IAAI3D,SAAO,QAASX,WAAWkI,KAAK/D,EAAEpI,MAAyBoI,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,SAChG,IAAK,UACL,OAAO,IAAIuG,SAAO,UAAWV,aAAaiI,KAAK/D,EAAEpI,MAAyBoI,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,SACpG,IAAK,OACL,OAAO,IAAIuG,SAAO,OAAQZ,WAAWmI,KAAK/D,EAAEpI,MAAyBoI,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,SAC/F,QACA,MAAM,IAAI+C,MAAM,iCAIf,SAASiH,EAAQD,EAAWxG,GACjC,OExVK,SAAiBwC,EAAWzE,GAKjC,IAJA,IAAMqD,EAAelD,EAAUsM,sBAAsBhI,EAAExC,KAAMjC,GACvDyF,EAAS,IAAIR,SAAOR,EAAEL,KAAMD,EAAeuB,iBAAiBjB,EAAEL,KAAMK,EAAEpE,KAAK3B,QAAS2E,GACpFuD,EAAInC,EAAEpE,KACNsF,EAAIF,EAAOpF,KACTjB,EAAI,EAAGA,EAAIqF,EAAEpE,KAAK3B,SAAUU,EAClCuG,EAAEvG,GAAKwH,EAAExH,GAEX,OAAOqG,EFgVAiH,CAAYjE,EAAGxG,GAIjB,SAAS0K,EAAOlE,GAA8B,IAAnBjG,EAAkB,uDAAX,EACvC,GAAe,YAAXiG,EAAErE,MAAiC,UAAXqE,EAAErE,KAC5B,MAAM,IAAI3C,MAAM,kCAElB,IAAMmB,EAAO6F,EAAExG,KAAOwG,EAAExG,KAAKvD,OAAS,EACtC8D,EAAOrC,EAAUoG,+BAA+B/D,EAAMI,GAKtD,IAVkD,MAMjBzC,EAAUyM,iBAAiBnE,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,QAAS8D,GAN7C,mBAM3CqK,EAN2C,KAM/BC,EAN+B,KAO5ClG,EAAI6B,EAAEpI,KACNsF,EAAIxB,EAAeuB,iBAAiB,QAA+B,IAAtBoH,EAAWpO,OAAe,EAAIyB,EAAUD,KAAK4M,IAC1FtL,EAAYqL,EAAW,GACpBzN,EAAI,EAAGA,EAAIuG,EAAEjH,SAAUU,EAAG,CAIjC,IAHA,IAAMsC,EAASF,EAAYpC,EACvBN,EAAM8H,EAAElF,GACRf,EAAQ,EACHH,EAAI,EAAGA,EAAIgB,IAAahB,EAAG,CAClC,IAAMuG,EAAQH,EAAElF,EAASlB,GACrBuG,EAAQjI,IACVA,EAAMiI,EACNpG,EAAQH,GAGZmF,EAAEvG,GAAKuB,EAET,OAAO,IAAIsE,SAAO,QAASU,EAAyB,IAAtBmH,EAAWpO,OAAe,CAAC,GAAKoO,GAGzD,SAAShO,EAAI2J,GAAgD,IAArCjG,EAAoC,uDAA7B,EAAGuK,EAA0B,wDACjE,GAAe,YAAXtE,EAAErE,MAAiC,UAAXqE,EAAErE,KAC5B,MAAM,IAAI3C,MAAM,kCAElB,IAAMmB,EAAO6F,EAAExG,KAAOwG,EAAExG,KAAKvD,OAAS,EACtC8D,EAAOrC,EAAUoG,+BAA+B/D,EAAMI,GAKtD,IAViE,MAMhCzC,EAAUyM,iBAAiBnE,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,QAAS8D,GAN9B,mBAM1DqK,EAN0D,KAM9CC,EAN8C,KAO3DlG,EAAI6B,EAAEpI,KACNsF,EAAIxB,EAAeuB,iBAAiB+C,EAAErE,KAA4B,IAAtB0I,EAAWpO,OAAe,EAAIyB,EAAUD,KAAK4M,IACzFtL,EAAYqL,EAAW,GACpBzN,EAAI,EAAGA,EAAIuG,EAAEjH,SAAUU,EAAG,CAGjC,IAFA,IAAMsC,EAASF,EAAYpC,EACvBN,EAAM8H,EAAElF,GACHlB,EAAI,EAAGA,EAAIgB,IAAahB,EAAG,CAClC,IAAMuG,EAAQH,EAAElF,EAASlB,GACrBuG,EAAQjI,IACVA,EAAMiI,GAGVpB,EAAEvG,GAAKN,EAGT,IAAIkO,EAA+B,GACnC,GAAGD,EAED,IADA,IAAME,EAAWxE,EAAExG,KAAOwG,EAAExG,KAAO,CAACwG,EAAEpI,KAAK3B,QACnCU,EAAI,EAAGA,EAAI6N,EAASvO,SAAUU,EAC/BA,IAAMoD,EACPwK,EAAmB9I,KAAK,GAExB8I,EAAmB9I,KAAK+I,EAAS7N,SAIvC4N,EAAqBF,EAEvB,OAAO,IAAI7H,SAAOwD,EAAErE,KAAMuB,EAAiC,IAA9BqH,EAAmBtO,OAAe,CAAC,GAAKsO,GG5ZxD,OACX,YACA,UACA,OACA,OACA,SACA,MACA,MACA,MACA,QACA,MACA,cACA,MACA,QACA,YACA,SACA,cACA,QACA,OACA,QACA,aCdE7O,EAAUC,EAAQ,IAClB8O,EAAM9O,EAAQ,IACd+O,EAAM/O,EAAQ,GAEdgP,GAAe,IAAInI,SACrB,UACA,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,KAAM,KAAM,MAAO,OACzD,CAAC,EAAG,IASKoI,GAAb,WAGE,aAAe,yBAFfC,aAEc,EACZ,IAAMC,EAAQnP,EAAQ,IACtBoP,KAAKF,QAAUH,EAAIM,iBAAiBC,OAAOH,EAAMI,SALrD,8EAQE,WAAUC,GAAV,2BAAArO,EAAA,6DACMsO,EAAcL,KAAKM,WAAWF,GAC5BG,EAAQ,CAAEC,MAAOH,GAFzB,SAIwBL,KAAKF,QAJ7B,cAIQA,EAJR,gBAKwBA,EAAQW,IAAIF,GALpC,cAKQG,EALR,OAOQC,EAAiB,IAAIlJ,SAAO,UAAWiJ,EAAQE,KAAK/N,KAAsB,CAAC,EAAG,IAAK,GAAI,KACvFgO,EAAepH,EAAUkH,EAAgB,CAAC,EAAG,EAAG,EAAG,IAR3D,UAUqBX,KAAKc,YAAYD,EAAc,IAVpD,eAUME,EAVN,OAWEC,QAAQC,IAAIF,GAXd,kBAYSA,GAZT,iDARF,+EAuBE,SAAWG,GAAsC,IACvCrO,EAAwBqO,EAAxBrO,KAAMsO,EAAkBD,EAAlBC,MAAOC,EAAWF,EAAXE,OAGfC,EAAa1Q,EAAQ,IAAIoG,aAAalE,GAAO,CAACsO,EAAOC,EAAQ,IAC7DE,EAAsB3Q,EAAQ,IAAIoG,aAAaoK,EAAQC,EAAS,GAAI,CACxE,EACA,EACAD,EACAC,IAsBF,OAnBA1B,EAAI6B,OACFD,EAAoB/K,KAAK,EAAG,EAAG,KAAM,MACrC8K,EAAW9K,KAAK,KAAM,KAAM,IAE9BmJ,EAAI6B,OACFD,EAAoB/K,KAAK,EAAG,EAAG,KAAM,MACrC8K,EAAW9K,KAAK,KAAM,KAAM,IAE9BmJ,EAAI6B,OACFD,EAAoB/K,KAAK,EAAG,EAAG,KAAM,MACrC8K,EAAW9K,KAAK,KAAM,KAAM,IAGf,IAAIkB,SAAO,UAAW6J,EAAoBzO,KAAM,CAC7D,EACA,EACAsO,EACAC,MApDN,gEAyDE,WAAkBP,EAAsBW,GAAxC,mEAAAzP,EAAA,+DACuDiO,KAAKyB,UACxDZ,EACAjB,GACA,IAJJ,mBACS8B,EADT,KACgBC,EADhB,KACuBC,EADvB,KACsCC,EADtC,KAMQC,EAAW9B,KAAK+B,sBAAsBL,EAAOC,GANrD,SAO+C3B,KAAKgC,kBAChDF,EACAF,EACAC,EA1EiC,KAgErC,sCAOSI,EAPT,KAOsBC,EAPtB,KAO8BC,EAP9B,KAcqB,MAAfF,EAdN,0CAeW,IAfX,eAkBQd,EAAQiB,EA/EA,KAgFRhB,EAASgB,EAhFD,KAkFRC,EAAYD,EAChBA,EAAW,CAAChB,EAAQD,EAAOC,EAAQD,IACnC,CAAC,EAAG,IAGAmB,EAAgBF,EAASH,EAAaI,GA1B9C,UA4B6CE,QAAQC,IAAI,CACrDF,EAAMzP,KACNqP,EAAOrP,OA9BX,2CA4BS4P,EA5BT,KA4B0BC,EA5B1B,OAiC2C1C,KAAK2C,oBAC5CF,EACAC,EAlGwB,IA+D5B,mBAiCSE,EAjCT,KAiCmBC,EAjCnB,KAiC6BC,EAjC7B,eAuCgCV,EAC5BD,EACA,IAAI1K,SAAO,QAASmL,IACpB/P,KA1CJ,eAuCQkQ,EAvCR,OA4CQrC,EAAiB,GAEvBqC,EAAepG,SAAQ,SAACqG,EAAWpR,GACjC,IAAMqR,EAAYH,EAAWlR,GAC7B,KAAIqR,EA9G2B,IA8G/B,CAIA,IAAMC,EAAYC,EAAWH,GANU,cAONH,EAASjR,GAPH,GAOlCwR,EAPkC,KAO7BC,EAP6B,KAOvBC,EAPuB,KAOfC,EAPe,KASvCH,EAAM/R,KAAKC,IAAI,EAAG8R,GAClBC,EAAOhS,KAAKC,IAAI,EAAG+R,GAInB,IAAMG,EAAY,CAChBN,YACAD,YACAK,OANFA,EAASjS,KAAKoS,IAAI,IAAKH,GAOrBF,MACAC,OACAE,MARFA,EAAQlS,KAAKoS,IAAI,IAAKF,IAWtB7C,EAAQhK,KAAK8M,OArEjB,kBAuES9C,GAvET,iDAzDF,+HAmIE,WACE4B,EACAV,EACAC,EACA6B,GAJF,6BAAA3R,EAAA,6DAMQ4R,EAAYvB,EAASR,EAAeC,GACpC+B,EAAaxB,EAAYuB,GAAY,GACrCE,EAAiBzB,EAASuB,GAAY,GAGtCG,EAAiB1B,EACrBA,EAAkByB,EAAgBzB,EAAYsB,KAG1C1K,EAAI8K,EAAepR,KAEnBqR,EAAa3B,EAAUA,EAAc,EAAGpJ,EAAI,EAAGA,GAAI,SACnDgL,EAAa5B,EAAW,CAACpJ,GAAI,SAC7B/G,EAAUmQ,EAAW0B,EAAgBC,EAAYC,GAnBzD,kBAqBS,CACL5B,EAAYA,EAAaE,EAAO,CAACtJ,EAAG,IAAK/G,GACzCmQ,EAAYA,EAAUyB,GAAiB5R,GACvCmQ,EAAYA,EAAUwB,GAAa3R,KAxBvC,2CAnIF,gGAsKE,SAAsByP,EAAeC,GACnC,IAAMsC,EAAM,IAAIxM,SAAO,UAAW,CAAC,IAC7ByM,EJ7FH,SAAahI,EAAYC,GAC9B,GAAiB,YAAZD,EAAGtF,MAAkC,UAAZsF,EAAGtF,MAAkC,YAAZuF,EAAGvF,MAAkC,UAAZuF,EAAGvF,KACjF,MAAM,IAAI3C,MAAM,kCAElB,GAAIiI,EAAGtF,OAASuF,EAAGvF,KACjB,MAAM,IAAI3C,MAAM,6BAElB,OAAO+C,EAASkF,EAAIC,GAAI,SAACC,EAAIC,GAAL,OAAaD,EAAKC,IAAKH,EAAGtF,MIsFhCwL,CAASV,EAAOU,EAAST,EAAOsC,IAC1CE,EAAW/B,EAASV,EAAOU,EAAST,EAAOsC,IAK3CvR,EAAO,CAHAwR,EAAQzP,KAAK,GACbyP,EAAQzP,KAAK,GACbyP,EAAQzP,KAAK,GACM,GAEhC,OAAO2N,EACL,CACEA,EAAW8B,EAAS,CAAC,EAAG,EAAG,EAAG,GAAIxR,GAClC0P,EAAW8B,EAAS,CAAC,EAAG,EAAG,EAAG,GAAIxR,GAClC0P,EAAW+B,EAAU,CAAC,EAAG,EAAG,EAAG,GAAIzR,GACnC0P,EAAW+B,EAAU,CAAC,EAAG,EAAG,EAAG,GAAIzR,IAErC,KAvLN,iCAmMG,SACC4P,EACAJ,EACAkC,GAIA,IAHC,IAAD,OAEMC,EAAS,GACNzS,EAAI,EAAGA,EAAIsQ,EAAOhR,OAAQU,IACjCyS,EAAO3N,KAAK,CACVwL,EAAOtQ,GACP,CAAC0Q,EAAM,EAAI1Q,GAAI0Q,EAAM,EAAI1Q,EAAI,GAAI0Q,EAAM,EAAI1Q,EAAI,GAAI0Q,EAAM,EAAI1Q,EAAI,IACjEA,IAKJ,IAAM0S,EAAcD,EAAOE,MAAK,SAACxS,EAAOC,GAAR,OAAkBA,EAAE,GAAKD,EAAE,MAErDyS,EAAuB,GAqB7B,OAjBAF,EAAY3H,SAAQ,SAAC8H,GAEnB,IADA,IAAIxI,GAAM,EACDrK,EAAI,EAAGA,EAAI4S,EAActT,OAAQU,IAAK,CAI7C,GADe,EAAK8S,QAAQD,EAAI,GAAID,EAAc5S,GAAG,IACxCwS,EAAc,CACzBnI,GAAM,EACN,OAGAA,GACFuI,EAAc9N,KAAK+N,MAKhB,CACLD,EAAcvO,KAAI,SAAC0O,GAAD,OAAOA,EAAE,MAC3BH,EAAcvO,KAAI,SAAC0O,GAAD,OAAOA,EAAE,MAC3BH,EAAcvO,KAAI,SAAC0O,GAAD,OAAOA,EAAE,SA7OjC,uBAkPE,SAAUC,EAAeC,EAAiBrD,GACxC,IAAMsD,EAAaD,EAAQpQ,KAAK,GAE1BsQ,EAAe3C,EAAayC,EAAS,CAAC,EAAG,EAAGC,EAAY,IAExDE,EAAWJ,EAAMnQ,KAAKpC,MAAM,EAAG,GAG/B4S,EAAYD,EAAS,GACrBE,EAAYF,EAAS,GAEvBG,EAAkB/C,EAAW,EAAG4C,EAAS,IACzCI,EAAiBhD,EAAW,EAAG4C,EAAS,IAE5CG,EAAkB/C,EAAU+C,EAAiB,CAACH,EAAS,KAMvDI,EAAiBhD,EAAUA,EAJ3BgD,EAAiBhD,EAAUA,EAAgBgD,EAAgB,GAAI,CAC7DJ,EAAS,GACT,MAIF,IAAIK,EAAYjD,EAAeA,EAAW,CAAC+C,EAAiBC,KAE5DC,EAAYjD,EADZiD,EAAYjD,EAAaiD,EAAW,CAACL,EAAS,GAAIA,EAAS,GAAI,EAAG,IACjCJ,EAAMhO,MAEvCgO,EAAQxC,EAAawC,EAAO,CAC1BI,EAAS,GACTA,EAAS,GACTF,EACAtD,EAAa,IAEf,IAAM8D,EAAiBlD,EACrBA,EAAa,IAAI3K,SAAO,QAASuN,GAAW,CAAC,EAAG,EAAG,EAAG,IACtDJ,EAAMhO,MAGJ8K,EAAQU,EACVA,EAAWwC,EAAO,CAAC,EAAG,EAAG,EAAG,GAAI,CAACK,EAAWC,EAAWJ,EAAY,KAEjEnD,EAAQS,EACVA,EAAWwC,EAAO,CAAC,EAAG,EAAG,EAAG,GAAI,CAACK,EAAWC,EAAWJ,EAAY,KAE/DlD,EAAgBQ,EACpBA,EAAWwC,EAAO,CAAC,EAAG,EAAG,EAAG,GAAI,CAACK,EAAWC,EAAWJ,EAAY,KAE/DjD,EJrLH,SAAiB5G,GAA8B,IAAnBsK,EAAkB,wDAAX,EACxC,GAAe,YAAXtK,EAAErE,MAAiC,UAAXqE,EAAErE,KAC5B,MAAM,IAAI3C,MAAM,kCAElB,OAAOuR,EAAYvK,EAAGsK,GIiLEnD,CACpBA,EACEwC,EACA,CAAC,EAAG,EAAG,EAAG,GACV,CAACK,EAAWC,EAAWJ,EAAYtD,KAQvC,MAAO,CAJPE,EAAQU,EAASA,EAASV,EAAO2D,GAAYC,GAC7C3D,EAAQS,EAASA,EAAST,EAAOoD,GAAeO,GAG1B1D,EAAeC,KA5SzC,8BA+SE,SAAiB9P,EAAaC,GAC5B,IAAMyT,EAAIpU,KAAKoS,IAAI1R,EAAE,GAAIC,EAAE,IAAMX,KAAKC,IAAIS,EAAE,GAAIC,EAAE,IAC5C0T,EAAIrU,KAAKoS,IAAI1R,EAAE,GAAIC,EAAE,IAAMX,KAAKC,IAAIS,EAAE,GAAIC,EAAE,IAClD,OAAIyT,EAAI,GAAKC,EAAI,EACR,EAEFD,EAAIC,IArTf,uBAwTE,SAAU3T,EAAaC,GACrB,IAAMJ,EAAIoO,KAAK2F,iBAAiB5T,EAAGC,GACnC,OAAQD,EAAE,GAAKA,EAAE,KAAOA,EAAE,GAAKA,EAAE,KAAOC,EAAE,GAAKA,EAAE,KAAOA,EAAE,GAAKA,EAAE,IAAMJ,IA1T3E,qBA6TE,SAAQG,EAAaC,GACnB,OAAOgO,KAAK2F,iBAAiB5T,EAAGC,GAAKgO,KAAK4F,UAAU7T,EAAGC,OA9T3D,KChBa6T,GAAb,WAMI,WAAYC,EAAwBC,GAA2B,yBAL/DD,WAK8D,OAJ9DC,YAI8D,OAH9DC,SAG8D,OAF9DjG,WAE8D,EAE1DC,KAAK8F,MAAQA,EAGb9F,KAAK+F,OAASA,EACd/F,KAAK+F,OAAO5E,MAAQ,IACpBnB,KAAK+F,OAAO3E,OAAS,IACrBpB,KAAKgG,IAAMhG,KAAK+F,OAAOE,WAAW,MAClCjG,KAAKD,MAAQ,IAAIF,GAfzB,wFAkBI,WAAoBqG,GAApB,oBAAAnU,EAAA,sDACIiO,KAAK8F,MAAMK,YAAc,EAEzBnG,KAAK8F,MAAMM,SAAX,sBAAsB,4CAAArU,EAAA,yDACb,EAAKiU,IADQ,wDAKZK,EAAe,EAAKL,IAAID,OAAO3E,OAC/BkF,EAAc,EAAKN,IAAID,OAAO5E,MAEhCC,EAAS,EAAK0E,MAAMS,YACpBpF,EAAQ,EAAK2E,MAAMU,WAEnBpF,EAASiF,IAETjF,GADIqF,EAAcJ,EAAejF,EAEjCD,GAASsF,GAGTtF,EAAQmF,IAERlF,GADIqF,EAAcH,EAAcnF,EAEhCA,GAASsF,GAGPC,GAAYJ,EAAcnF,GAAS,EACnCwF,GAAYN,EAAejF,GAAU,EAE3C,EAAK4E,IAAIY,UAAU,EAAE,EAAEN,EAAaD,GACpC,EAAKL,IAAIa,UAAU,EAAKf,MAAOY,EAAUC,EAAUxF,EAAOC,GACtD0F,EAAU,EAAKd,IAAIe,aAAa,EAAG,EAAGT,EAAaD,GA5BrC,UA6BC,EAAKtG,MAAMU,IAAIqG,GA7BhB,eA8BXnK,SAAQ,SAACqK,GACI,MAAZ,EAAKhB,MAET,EAAKA,IAAIiB,KAAO,aAChB,EAAKjB,IAAIkB,UAAY,MACrB,EAAKlB,IAAImB,SAASH,EAAK9D,UAAW8D,EAAK3D,KAAM2D,EAAK5D,IAAM,IAGxD,EAAK4C,IAAIoB,YACT,EAAKpB,IAAIqB,UAAY,EACrB,EAAKrB,IAAIsB,YAAc,MACvB,EAAKtB,IAAIuB,KAAKP,EAAK3D,KAAM2D,EAAK5D,IAAM4D,EAAKzD,MAAMyD,EAAK3D,KAAQ2D,EAAK1D,OAAS0D,EAAK5D,KAC/E,EAAK4C,IAAIwB,aA1CK,4CAH1B,gDAlBJ,+EAqEI,WAAa,IAAD,OACRxH,KAAK8F,MAAM2B,aAAe,WAAO,IAAD,EAC5B,YAAKzB,WAAL,SAAUa,UAAU,EAAKf,MAAO,EAAG,EAAG,EAAKA,MAAMU,WAAY,EAAKV,MAAMS,kBAvEpF,K,QCyBemB,OA3Bf,WACE,IAAMC,EAAWC,iBAAyB,MACpCC,EAAYD,iBAA0B,MAE5CE,qBAAU,WACgB,MAApBH,EAASI,SAAwC,MAArBF,EAAUE,SACpB,IAAIlC,GAAY8B,EAASI,QAASF,EAAUE,SACpDC,cAAc,OAK9B,IAAMlC,EAAQlV,EAAQ,IACtB,OACE,sBAAKsS,UAAU,MAAf,SACE,0BAAQA,UAAU,aAAlB,UACE,+BACE,wBAAO+E,IAAKN,EAAUO,IAAKpC,EAAM3F,QAASgI,UAAU,MAEtD,+BACE,yBAAQF,IAAKJ,EAAW1G,MAAM,MAAMC,OAAO,eCVtCgH,GAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,eAAC,IAAMC,WAAP,UACE,eAAC,GAAD,MAEFC,SAASC,eAAe,SAM1Bb,O","file":"static/js/main.4fa2c357.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/tinyyolov2-7.58217825.onnx\";","export default __webpack_public_path__ + \"static/media/sample_720p.a1f8438b.mp4\";","import {Type, NumberDataType} from './yoloPostprocess';\nconst ndarray = require(\"ndarray\");\n\n  export class BroadcastUtil {\n    /**\n     * Calculate the expected shape when broadcasting 2 tensors\n     * @param a The shape of tensor A. Should be an array of positive integers\n     * @param b The shape of tensor B. Should be an array of positive integers\n     * @param isMatMul Whether the operation is MatMul\n     * @returns The expected shape of the result, or undefined if N/A\n     */\n    static calcShape(adims: ReadonlyArray<number>, bdims: ReadonlyArray<number>, isMatMul = false): number[]|undefined {\n      const arank = adims.length;\n      const brank = bdims.length;\n      const crank = Math.max(adims.length, bdims.length);\n      const cdims = new Array<number>(crank);\n  \n      // calculate the last 2 dimension if it is MatMul\n      if (isMatMul) {\n        if (arank < 2 || brank < 2) {\n          return undefined;\n        }\n        const cShapeMatMul =\n            BroadcastUtil.calcMatMulShape([adims[arank - 2], adims[arank - 1]], [bdims[brank - 2], bdims[brank - 1]]);\n        if (cShapeMatMul === undefined) {\n          return undefined;\n        }\n        [cdims[crank - 2], cdims[crank - 1]] = cShapeMatMul;\n      }\n  \n      for (let i = isMatMul ? 3 : 1; i <= crank; i++) {\n        const aLen = arank - i < 0 ? 1 : adims[arank - i];\n        const bLen = brank - i < 0 ? 1 : bdims[brank - i];\n  \n        if (aLen !== bLen && aLen > 1 && bLen > 1) {\n          return undefined;\n        }\n        cdims[crank - i] = Math.max(aLen, bLen);\n      }\n  \n      return cdims;\n    }\n  \n    /**\n     * Calculate the expected shape when matrix multiplication\n     * @param a The shape of tensor A. Should be a tuple of 2 positive integers\n     * @param b The shape of tensor B. Should be a tuple of 2 positive integers\n     * @returns The expected shape of the result, or undefined if N/A\n     */\n    static calcMatMulShape(a: [number, number], b: [number, number]): [number, number]|undefined {\n      return (a[1] !== b[0]) ? undefined : [a[0], b[1]];\n    }\n  \n    /**\n     * Given the indices of a broadcasted tensor, calculate the original indices\n     * @param indices The given indices of the broadcasted tensor.\n     * @param shapeOrigin The origin shape of the tensor before broadcast\n     * @param isMatMul Whether the operation is MatMul\n     * @returns The calculated indices that maps to the original tensor. If the\n     * operation is MatMul, the indices of last 2 dimensions will keep as same as\n     * input indices\n     */\n    static index(indices: number[], shapeOrigin: number[], isMatMul = false): number[] {\n      // we assume the parameter indices is valid. ie. it should have the same\n      // length as the broadcasted shape, and for each dimension the index should\n      // not be out of range.\n      const dimOffset = indices.length - shapeOrigin.length;\n      const indicesOrigin = indices.slice(dimOffset);\n      const dimLen = isMatMul ? indicesOrigin.length - 2 : indicesOrigin.length;\n      for (let i = 0; i < dimLen; i++) {\n        indicesOrigin[i] = indices[dimOffset + i] % shapeOrigin[i];\n      }\n      return indicesOrigin;\n    }\n  \n    /**\n     * Perform the broadcasting operation on the specific operator\n     * @param a The input tensor A\n     * @param b The input tensor B\n     * @param op The operator lambda function\n     * @returns The result tensor, or undefined if input not broadcastable.\n     */\n    static calc(a: any, b: any, op: (a: number, b: number) => number): any|undefined {\n      const shape = BroadcastUtil.calcShape(a.shape, b.shape);\n      if (shape) {\n        const size = ShapeUtil.size(shape);\n        const c = ndarray(\n            new (\n                a.data.constructor as Int8ArrayConstructor | Int16ArrayConstructor | Int32ArrayConstructor |\n                Uint8ArrayConstructor | Uint16ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor |\n                Float64ArrayConstructor | Uint8ClampedArrayConstructor)(size),\n            shape);\n  \n        const indices = new Array<number>(shape.length);\n        for (let i = 0; i < size; i++) {\n          // traversal indices\n          let rest = i;\n          for (let j = shape.length - 1; j >= 0; j--) {\n            indices[j] = rest % shape[j];\n            rest = Math.floor(rest / shape[j]);\n          }\n  \n          // map index\n          const indicesA = BroadcastUtil.index(indices, a.shape);\n          const indicesB = BroadcastUtil.index(indices, b.shape);\n  \n          // assign value\n          c.set(...indices.concat(op(a.get(...indicesA), b.get(...indicesB))));\n        }\n  \n        return c;\n      }\n  \n      return undefined;\n    }\n  \n    /**\n     * Determine if a shape is unidirectional broadcastable to another shape\n     * @param shape The input shape\n     * @param finalShape The desired shape after broadcasting\n     */\n    static isValidBroadcast(shape: ReadonlyArray<number>, finalShape: ReadonlyArray<number>): boolean {\n      // align shape to the right\n      const inputRank = shape.length;\n      const finalRank = finalShape.length;\n      if (inputRank > finalRank) {\n        return false;\n      }\n      for (let i = 1; i <= inputRank; i++) {\n        if (shape[inputRank - i] !== 1 && shape[inputRank - i] !== finalShape[finalRank - i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  // copy array helper\n  // mimics memcpy as much as possible\n  export function arrayCopyHelper(\n      target: NumberDataType, source: NumberDataType, targetIndex: number, sourceIndex: number,\n      blockSize: number) {\n    if (sourceIndex < 0 || sourceIndex >= source.length) {\n      throw new Error(`sourceIndex out of bounds`);\n    }\n    if (targetIndex < 0 || targetIndex >= target.length) {\n      throw new Error(`targetIndex out of bounds`);\n    }\n    if (sourceIndex + blockSize > source.length) {\n      throw new Error(`source indices to be copied are outside bounds`);\n    }\n    if (targetIndex + blockSize > target.length) {\n      throw new Error(`target array is too small to hold result`);\n    }\n  \n    for (let offset = 0; offset < blockSize; offset++) {\n      target[targetIndex + offset] = source[sourceIndex + offset];\n    }\n  }\n  \n  export class TypeUtil {\n    static validateSameTypes(typesArray: Type[]) {\n      if (typesArray.length < 2) {\n        throw new Error('must contain atleast 2 types to compare equality');\n      }\n      const baseType = typesArray[0];\n      for (let i = 0; i < typesArray.length; ++i) {\n        if (typesArray[i] !== baseType) {\n          throw new Error('input types are ');\n        }\n      }\n    }\n  }\n  \n  export class ShapeUtil {\n    static validateEqualDims(dimsArray: Array<ReadonlyArray<number>>) {\n      if (dimsArray.length < 2) {\n        throw new Error('must contain atleast 2 shapes to compare equality');\n      }\n      const baseDims = dimsArray[0];\n      const baseRank = baseDims.length;\n      for (let i = 1; i < dimsArray.length; ++i) {\n        const dims = dimsArray[i];\n        if (dims.length !== baseRank) {\n          throw new Error('rank is not the same for given inpu shapes');\n        }\n        for (let j = 0; j < baseRank; ++j) {\n          if (baseDims[j] !== dims[j]) {\n            throw new Error('input shapes are not the same');\n          }\n        }\n      }\n    }\n  \n    static validateDims(dims: ReadonlyArray<number>) {\n      if (dims.length < 0 || dims.length > 6) {\n        throw new TypeError(`Only rank 0 to 6 is supported for tensor shape.`);\n      }\n  \n      if (dims.length === 0) {\n        throw new RangeError('Scaler tensor is not implemented yet');\n      }\n  \n      for (const n of dims) {\n        if (!Number.isInteger(n)) {\n          throw new TypeError(`Invalid shape: ${n} is not an integer`);\n        }\n        if (n <= 0 || n > 2147483647) {\n          throw new TypeError(`Invalid shape: length ${n} is not allowed`);\n        }\n      }\n    }\n  \n    static size(dims: ReadonlyArray<number>): number {\n      return ShapeUtil.getSizeFromDimensionRange(dims, 0, dims.length);\n    }\n  \n    static sizeFromDimension(dims: ReadonlyArray<number>, axis: number): number {\n      if (axis > dims.length) {\n        throw new Error(`invalid dimension of ${axis} for sizeFromDimension as Tensor has ${dims.length} dimensions.`);\n      }\n  \n      return ShapeUtil.getSizeFromDimensionRange(dims, axis, dims.length);\n    }\n  \n    static sizeToDimension(dims: ReadonlyArray<number>, axis: number): number {\n      if (axis > dims.length) {\n        throw new Error(`invalid dimension of ${axis} for sizeToDimension as Tensor has ${dims.length} dimensions.`);\n      }\n  \n      return ShapeUtil.getSizeFromDimensionRange(dims, 0, axis);\n    }\n  \n    static getSizeFromDimensionRange(dims: ReadonlyArray<number>, start: number, end: number): number {\n      let size = 1;\n      for (let i = start; i < end; i++) {\n        // safety check as this method is called by multiple other methods requiring size.\n        // size cannot be 0 or negative.\n        if (dims[i] <= 0) {\n          throw new Error(\n              // tslint:disable-next-line:max-line-length\n              `cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.`);\n        }\n        size *= dims[i];\n      }\n      return size;\n    }\n  \n    // Computes the offset up until the start index for the specified axis\n    /**\n     * @param index Given index to compute offset for in the flattened\n     * @param stride The strides of the tensor corresponding to the index\n     * @param axis The 1-indexed axis upto which the offset is to be computed for. If undefined, axis == rank of the\n     * index.\n     */\n  \n    static computeOffset(index: number[], stride: number[], axis?: number) {\n      if (axis === undefined) {\n        axis = index.length;\n      }\n      let offset = 0;\n      for (let i = 0; i < axis; ++i) {\n        offset += (index[i] * stride[i]);\n      }\n      return offset;\n    }\n    static computeStrides(shape: ReadonlyArray<number>): number[] {\n      const rank = shape.length;\n      if (rank < 2) {\n        return [1];\n      }\n  \n      const strides = new Array(rank);\n      strides[rank - 1] = 1;\n      strides[rank - 2] = shape[rank - 1];\n      for (let i = rank - 3; i >= 0; --i) {\n        strides[i] = strides[i + 1] * shape[i + 1];\n      }\n      return strides;\n    }\n    static transpose(dims: number[]): number[] {\n      return dims.reverse();\n    }\n    static indicesToOffset(indices: number[], strides: number[]): number {\n      const rank = strides.length;\n      if (rank === 0) {\n        return 0;\n      }\n      let index = indices[indices.length - 1];\n      for (let i = 0; i < indices.length - 1; ++i) {\n        index += strides[i] * indices[i];\n      }\n      return index;\n    }\n  \n    static offsetToIndices(offset: number, strides: number[]): number[] {\n      const rank = strides.length;\n      if (rank === 0) {\n        return [];\n      } else if (rank === 1) {\n        return [offset];\n      }\n      const indices: number[] = new Array(strides.length);\n      for (let i = 0; i < indices.length - 1; ++i) {\n        indices[i] = Math.floor(offset / strides[i]);\n        offset -= indices[i] * strides[i];\n      }\n      indices[indices.length - 1] = offset;\n      return indices;\n    }\n    static getActualAxisFromNegativeValue(axis: number, tensorRank: number): number {\n      if (axis < -tensorRank && axis >= tensorRank - 1) {\n        throw new Error('unsupported axis for this operation.');\n      }\n      return axis < 0 ? axis + tensorRank : axis;\n    }\n  \n    // Increment an index into a tensor (in lexicographic\n    // ordering), wrapping around the specified upper_bound.\n    /**\n     * Increment an index into a tensor (in lexicographic ordering), wrapping around the specified upper_bound.\n     * @param index Given index to increment\n     * @param dims The dimensions of the tensor for which the given index corresponds to\n     * @param axisToIncrementOn The 1-indexed axis to increment on. If undefined, axisToIncrementOn == rank\n     */\n    static incrementIndex(index: number[], dims: number[], axisToIncrementOn?: number) {\n      if (axisToIncrementOn === undefined) {\n        axisToIncrementOn = dims.length;\n      }\n  \n      for (let k = axisToIncrementOn - 1; k >= 0; --k) {\n        index[k]++;\n        if (index[k] < dims[k]) {\n          break;\n        }\n        index[k] = 0;\n      }\n    }\n\n  /**\n   * Produces a new dimensions array based on the values in the 'originalDimensions' and 'shape' array\n   * Used in Reshape\n   * @param originalDims Original Shape array\n   * @param shapeHints array containing values to compute the new dimensions\n   * For example:\n   * originalDims = [2,2] and shapeHints = [0,-1] will return [2,2]\n   * originalDims = [2,2] and shapeHints = [4] will return [4]\n   * originalDims = [2,2] and shapeHints = [5] will throw an exception\n   * https://github.com/onnx/onnx/blob/master/docs/Operators.md#Reshape\n   */\n\n  static calculateReshapedDims(originalDims: ReadonlyArray<number>, shapeHints: ReadonlyArray<number>): number[] {\n    const nDims = shapeHints.length;\n    const reshapedDims = new Array<number>(nDims);\n    let unknownDimension = -1;\n    let size = 1;\n\n    for (let i = 0; i < nDims; i++) {\n      if (shapeHints[i] < -1) {\n        throw new Error('a dimension cannot be less than -1');\n      }\n      if (shapeHints[i] === -1) {\n        if (unknownDimension !== -1) {\n          throw new Error('at most one dimension can be -1');\n        }\n        unknownDimension = i;\n      } else {\n        if (shapeHints[i] === 0) {\n          if (i >= originalDims.length) {\n            throw new Error('the dimension with value zero exceeds the dimension size of the input tensor');\n          }\n          reshapedDims[i] = originalDims[i];\n        } else {\n          reshapedDims[i] = shapeHints[i];\n        }\n        size *= reshapedDims[i];\n      }\n    }\n\n    if (unknownDimension !== -1) {\n      const originalTensorFlattenedSize = ShapeUtil.size(originalDims);\n      if (originalTensorFlattenedSize % size !== 0) {\n        throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${\n            originalDims}] Output shape: [${shapeHints}]`);\n      }\n      reshapedDims[unknownDimension] = originalTensorFlattenedSize / size;\n    }\n    return reshapedDims;\n  }\n  \n  /**\n   * Sorts a given array based on the indices in the Perm array\n   * Used in Transpose\n   * @param a Array to be sorted such as dims or strides\n   * @param perm Perm given; if null a will be reversed\n   */\n  static sortBasedOnPerm(a: ReadonlyArray<number>, perm?: number[]): number[] {\n      if (perm) {\n        return perm.map((v) => a[v]);\n      } else {\n        return a.slice().reverse();\n      }\n  }\n  \n  /**\n   * Pads a given shape according to the padding values\n   * @param dims shape of the Tensor to be padded\n   * @param pad pad values\n   */\n  static padShape(dims: ReadonlyArray<number>, pad: number[]): number[] {\n    const rank = dims.length;\n    return dims.map((v, i) => v + pad[i] + pad[i + rank]);\n  }\n  \n  /**\n   * Determines if the two shapes are identical\n   * @param shape1\n   * @param shape2\n   */\n  static areEqual(shape1: ReadonlyArray<number>, shape2: ReadonlyArray<number>): boolean {\n    if (shape1.length !== shape2.length) {\n      return false;\n    }\n    return shape1.every((v, i) => v === shape2[i]);\n  }\n\n  /**\n   * Splits a given `dims` into 2 mutually exclusive `dims`\n   * @param dims ReadonlyArray<number>\n   * @param pick number - picks the dim along this axis and composes a new `dims`. \n   * The remnants make up another `dims` \n   */\n  static splitDimsIntoTwo(dims: ReadonlyArray<number>, pick: number): [number[], number[]] {\n    const picked: number[] = [];\n    const remnants: number[] = [];\n    \n    for(let i = 0; i < dims.length; ++i) {\n      if(i === pick) {\n        picked.push(dims[i]);\n      } else {\n        remnants.push(dims[i]);\n      }\n    }\n\n    return [picked, remnants];\n\n  }\n}\n  \nexport class TypedArrayUtil {\n  static createTypedArray(type: string, size: number): Uint8Array|Int32Array|Float32Array {\n      switch (type) {\n          case 'bool':\n          return new Uint8Array(size);\n          case 'int32':\n          return new Int32Array(size);\n          case 'float32':\n          return new Float32Array(size);\n          default:\n          throw new Error('Unsupported type');\n      }\n  }\n}","import {Tensor} from 'onnxruntime-web';\nimport { cast } from './yoloPostprocess';\nimport {NumberDataType, NumberOrBoolType} from './yoloPostprocess';\nimport {BroadcastUtil} from './yoloPostprocessUtils';\n\nconst ndarray = require(\"ndarray\");\n\nexport function binaryOp(\n  x: Tensor, y: Tensor, opLambda: (e1: number, e2: number) => number, resultType?: NumberOrBoolType): Tensor {\n    if (resultType === 'bool') {\n      x = cast(x, 'bool');\n      y = cast(y, 'bool');\n    }\n    const result =\n        BroadcastUtil.calc(ndarray(x.data as NumberDataType, \n                                   x.dims ? x.dims.slice(0) : [x.data.length]), \n                           ndarray(y.data as NumberDataType, \n                                   y.dims ? y.dims.slice(0) : [y.data.length]), opLambda);\n    if (!result) {\n      throw new Error('not broadcastable');\n    }\n    const rType = resultType ? resultType : x.type;  \n    const output = new Tensor(rType, result.data, result.shape);\n    return output;\n}","\nimport {Tensor} from 'onnxruntime-web';\nimport {ShapeUtil, TypedArrayUtil} from './yoloPostprocessUtils';\n\nexport function concat(x: Tensor[], axis: number): Tensor {\n  const input0 = x[0];\n  const inputShape = input0.dims ? input0.dims : [input0.data.length];\n\n  if (axis >= inputShape.length || axis < (-1 * inputShape.length)) {\n    throw new Error(`axis specified for concat doesn't match input dimensionality`);\n  }\n\n  if (axis < 0) {\n    axis = inputShape.length + axis;\n  }\n\n  // ensure all of the non-concatenated axes match each other\n  // along the way, calculate the shape of the output tensor\n  let concatAxisSize = inputShape[axis];\n  const outputShape = new Array<number>(inputShape.length);\n\n  for (let i = 1; i < x.length; i++) {\n    const dataN = x[i];\n    const dataNShape = dataN.dims ? dataN.dims : [dataN.data.length];\n\n    for (let axisIndex = 0; axisIndex < inputShape.length; axisIndex++) {\n      // add to the placeholder for computing output shape\n      if (axisIndex === axis) {\n        concatAxisSize += dataNShape[axisIndex];\n      }\n\n      // ensure all non-cancatenated axes match each other\n      if (inputShape[axisIndex] !== dataNShape[axisIndex]) {\n        throw new Error(`non concat dimensions must match`);\n      }\n\n      // fill the 'outputShape' array\n      outputShape[axisIndex] = dataNShape[axisIndex];\n    }\n  }\n\n  // complete the 'outputShape' array\n  outputShape[axis] = concatAxisSize;\n\n  // main logic\n  // tslint:disable-next-line:max-line-length\n  const output = new Tensor(input0.type, TypedArrayUtil.createTypedArray(x[0].type, ShapeUtil.size(outputShape)), outputShape);\n  const Y = output.data;\n\n  // the axisPitch is the number of elements to add to move\n  // to the next split axis in the output\n  let axisPitch = 1;\n  for (let i = outputShape.length - 1; i >= axis; i--) {\n    axisPitch *= outputShape[i];\n  }\n\n  let outputBase = 0;\n  for (let inputIndex = 0; inputIndex < x.length; inputIndex++) {\n    const dataN = x[inputIndex];\n    const dataNDims = dataN.dims ? dataN.dims : [dataN.data.length];\n\n    // the inputAxisPitch is the number of elements to add\n    // to move to the next split axis in the input\n    let inputAxisPitch = 1;\n    for (let i = dataNDims.length - 1; i >= axis; i--) {\n      inputAxisPitch *= dataNDims[i];\n    }\n\n    const inputData = dataN.data;\n    const inputSize = ShapeUtil.size(dataNDims);\n\n    // copy the data across.\n    // for every 'inputAxisPitch' values copied, we move over by\n    // the 'axisPitch'\n\n    let outputOffset = outputBase;\n\n    for (let i = 0, j = 0; i < inputSize; i++) {\n      Y[outputOffset + i] = inputData[i];\n      if (++j === inputAxisPitch) {\n        // subtract inputAxisPitch because output is being indexed by 'i'\n        outputOffset += (axisPitch - inputAxisPitch);\n        j = 0;\n      }\n    }\n    outputBase += inputAxisPitch;\n  }\n\n  return output;\n}","import {Tensor} from 'onnxruntime-web';\nimport {NumberDataType} from './yoloPostprocess';\nimport {ShapeUtil, TypedArrayUtil} from './yoloPostprocessUtils';\n\nexport function softmax(x: Tensor, axis: number): Tensor {\n  const inputDimensions = x.dims ? x.dims : [x.data.length];\n  const inputRank = inputDimensions.length;\n\n  const axisCorrected = ShapeUtil.getActualAxisFromNegativeValue(axis, inputRank);\n  const N = ShapeUtil.sizeToDimension(inputDimensions, axisCorrected);\n  const D = ShapeUtil.sizeFromDimension(inputDimensions, axisCorrected);\n\n  const X = x.data as NumberDataType;\n\n  const Y = TypedArrayUtil.createTypedArray(x.type, x.data.length);\n  \n  for (let i = 0; i < N; i++) {\n    // find row offset\n    const offset = i * D;\n\n    // find max of each logical row\n    let max = Number.MIN_VALUE;\n    for (let j = 0; j < D; j++) {\n      if (X[offset + j] > max) {\n        max = X[offset + j];\n      }\n    }\n\n    // find normalization scale per row\n    let scale = 0;\n    for (let j = 0; j < D; j++) {\n      const value = X[offset + j] - max;\n      Y[offset + j] = Math.exp(value);\n      scale += Math.exp(value);\n    }\n\n    // perform the softmax normalization\n    for (let j = 0; j < D; j++) {\n      if (scale === 0) {\n        Y[offset + j] = 0;\n      } else {\n        Y[offset + j] /= scale;\n      }\n    }\n  }\n\n  return new Tensor(x.type, Y, inputDimensions);\n}","\nimport {Tensor} from 'onnxruntime-web';\nimport { zeros } from './yoloPostprocess';\nimport {NumberDataType} from './yoloPostprocess';\nimport {arrayCopyHelper, ShapeUtil, TypedArrayUtil} from './yoloPostprocessUtils';\n\nexport function transpose(x: Tensor, perm?: number[]): Tensor {\n  const inputDims = x.dims ? x.dims : [x.data.length];\n  const rank = inputDims.length;\n\n  // determine permutation to use\n  // if no permutation was specified in the attributes,\n  // the default is [rank-1, ..., 0]\n  let finalPerm = new Array<number>(rank);\n  if (perm && perm.length === rank) {\n    finalPerm = perm;\n  } else {\n    for (let i = 0; i < rank; i++) {\n      finalPerm[i] = rank - i - 1;\n    }\n  }\n\n  const outputDims = new Array<number>(rank);\n  const stride = new Array<number>(rank);\n\n  // determine shape of output, as well as stride to be used\n  // stride[i] indicates the stride for the input-tensor dimension\n  // corresponding to the i-th dimension of the output\n  for (let i = 0; i < rank; i++) {\n    const inpDim = finalPerm[i];\n    outputDims[i] = inputDims[inpDim];\n    if (inpDim + 1 < rank) {\n      stride[i] = ShapeUtil.sizeFromDimension(inputDims, inpDim + 1);\n    } else {\n      stride[i] = 1;\n    }\n  }\n\n  const output = zeros(outputDims, x.type);\n\n  const X = x.data as NumberDataType;\n  const Y = output.data as NumberDataType;\n\n  // partition the permutation into a prefix and the largest suffix such that\n  // every axis i in the suffix is mapped to i.\n  let numAxesInPrefix = 0;  // number of axes in prefix\n  let suffixBlocksize = 1;  // product of dimensions in the suffix\n  let prefixBlocksize = 1;  // product of dimensions in the prefix\n  let isSuffix = true;\n  for (let i = rank - 1; i >= 0; --i) {\n    const inpAxis = finalPerm[i];\n    if (isSuffix && (inpAxis === i)) {\n      suffixBlocksize *= inputDims[inpAxis];\n    } else {\n      isSuffix = false;\n      prefixBlocksize *= inputDims[inpAxis];\n      ++numAxesInPrefix;\n    }\n  }\n\n  if (prefixBlocksize === 1) {\n    doTransposeSingleBlock(suffixBlocksize, Y, X);\n  } else if (suffixBlocksize === 1) {\n    doTransposeEltWise(numAxesInPrefix, outputDims, prefixBlocksize, stride, Y, X);\n  } else {\n    doTranspose(numAxesInPrefix, outputDims, prefixBlocksize, suffixBlocksize, stride, Y, X);\n  }\n\n  return output;\n}\n\n// doTranspose: copies source tensor to target, transposing elements.\n// the stride vector indicates the transposition.\nfunction doTranspose(\n    numAxes: number, targetDims: number[], numBlocks: number, numElementsInBlock: number, stride: number[],\n    target: NumberDataType, source: NumberDataType) {\n  const targetIndex = new Array<number>(numAxes).fill(0);\n\n  const startSourceIndex = 0;\n  let startTargetIndex = 0;\n\n  for (let i = 0; i < numBlocks; ++i) {\n    const sizeOffset = ShapeUtil.computeOffset(targetIndex, stride, numAxes);\n    arrayCopyHelper(target, source, startTargetIndex, startSourceIndex + sizeOffset, numElementsInBlock);\n\n    ShapeUtil.incrementIndex(targetIndex, targetDims, numAxes);\n    startTargetIndex += numElementsInBlock;\n  }\n}\n\n// doTransposeEltWise: specialization of DoTranspose for the\n// num_elts_in_block=1 case. copies source tensor to target, transposing\n// elements. The stride vector indicates the transposition.\nfunction doTransposeEltWise(\n    numAxes: number, targetDims: number[], numBlocks: number, stride: number[], target: NumberDataType,\n    source: NumberDataType) {\n  const targetIndex = new Array<number>(numAxes).fill(0);\n\n  let startTargetIndex = 0;\n\n  for (let i = 0; i < numBlocks; ++i) {\n    const sourceOffset = ShapeUtil.computeOffset(targetIndex, stride, numAxes);\n    target[startTargetIndex++] = source[sourceOffset];\n    ShapeUtil.incrementIndex(targetIndex, targetDims, numAxes);\n  }\n}\n\n// doTransposeSingleBlock: specialization of DoTranspose for the num_blocks=1\n// case. copies source tensor to target, transposing elements. The stride\n// vector indicates the transposition.\nfunction doTransposeSingleBlock(numElementsInBlock: number, target: NumberDataType, source: NumberDataType) {\n  arrayCopyHelper(target, source, 0, 0, numElementsInBlock);\n}","import {Tensor} from 'onnxruntime-web';\nimport {ShapeUtil, TypedArrayUtil, TypeUtil} from './yoloPostprocessUtils';\nimport * as unaryOps from './unary-op';\nimport {binaryOp} from './binary-op';\nimport {concat as concatImpl} from './concat';\nimport {softmax as softmaxImpl} from './softmax';\nimport {transpose as transposeImpl} from './transpose';\nimport {reshape as reshapeImpl} from './reshape';\n\n// Types\nexport type Type = Tensor.Type;\nexport type NumberType =  Tensor.Type | 'int32' | 'float32';\nexport type NumberOrBoolType = 'int32' | 'float32' | 'bool';\nexport type NumberDataType = Uint8Array | Int32Array | Float32Array;\n\n// Utility Tensor Creators\nexport function as1D(t: Tensor): Tensor {\n  return reshape(t, [t.data.length]);\n}\n\nexport function scalar(value: number, dtype: NumberType = 'float32'): Tensor {\n  if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error('Unsupported type for this transformation');\n  }\n  const data = TypedArrayUtil.createTypedArray(dtype, 1);\n  data[0] = value;\n  return new Tensor(dtype, data, [1]);\n}\n\nexport function zeros(dims: ReadonlyArray<number>, dtype: NumberType = 'float32'): Tensor {\n  if (dtype !== 'float32' && dtype !== 'int32' && dtype !== 'bool') {\n      throw new Error('Unsupported type for creating all zero Tensor');\n  }\n  ShapeUtil.validateDims(dims);\n  return new Tensor(dtype, TypedArrayUtil.createTypedArray(dtype, ShapeUtil.size(dims)), dims);\n}\n\nexport function linspace(start: number, stop: number, num: number): Tensor {\n  if (num === 0) {\n    throw new Error('Must request atleast one sample');\n  }\n  const increments = (stop - start) / (num - 1);\n  const data = TypedArrayUtil.createTypedArray('float32', num);\n  data[0] = start;\n  for (let i = 1; i < data.length; i++) {\n    data[i] = data[i - 1] + increments;\n  }\n  return new Tensor('float32', data, [num]);\n}\n\nexport function range(start: number, stop: number, step = 1, dtype: NumberType = 'float32'): Tensor {\n  if (step === 0) {\n    throw new Error('Step size of 0 is not acceptable');\n  }\n  // adjust default values\n  if (stop < step && step === 1) {\n    step = -1;\n  }\n  // the following conditions cannot generate any data\n  if (start === step || (start < stop && step < 0) || (stop < start && step > 0)) {\n    return new Tensor(dtype, TypedArrayUtil.createTypedArray(dtype, 1), [1]);\n  }\n  const size = Math.abs(Math.ceil((stop - start) / step));\n  const data = TypedArrayUtil.createTypedArray(dtype, size);\n  data[0] = start;\n  for (let i = 1; i < data.length; i++) {\n    data[i] = data[i - 1] + step;\n  }\n  return new Tensor(dtype, data, [size]);\n}\n\n// Basic Math Tensor Transforms\nexport function sigmoid(t: Tensor): Tensor {\n  if (t.type !== 'float32' && t.type !== 'int32') {\n    throw new Error('Unsupported type for transform');\n  }\n  return unaryOps.sigmoid(t);\n}\n  \nexport function exp(t: Tensor): Tensor {\n  if (t.type !== 'float32' && t.type !== 'int32') {\n    throw new Error('Unsupported type for transform');\n  }\n  return unaryOps.exp(t);\n}\n\n// Arithmetic Tensor Transforms\nexport function add(t1: Tensor, t2: Tensor): Tensor {\n  if ((t1.type !== 'float32' && t1.type !== 'int32') || (t2.type !== 'float32' && t2.type !== 'int32')) {\n    throw new Error('Unsupported type for transform');\n  }\n  if (t1.type !== t2.type) {\n    throw new Error('Types are not homogeneous');\n  }\n  return binaryOp(t1, t2, (e1, e2) => (e1 + e2), t1.type);\n}\n  \nexport function sub(t1: Tensor, t2: Tensor): Tensor {\n  if ((t1.type !== 'float32' && t1.type !== 'int32') || (t2.type !== 'float32' && t2.type !== 'int32')) {\n    throw new Error('Unsupported type for transform');\n  }\n  if (t1.type !== t2.type) {\n    throw new Error('Types are not homogeneous');\n  }\n  return binaryOp(t1, t2, (e1, e2) => (e1 - e2), t1.type);\n}\n  \nexport function mul(t1: Tensor, t2: Tensor): Tensor {\n  if ((t1.type !== 'float32' && t1.type !== 'int32') || (t2.type !== 'float32' && t2.type !== 'int32')) {\n    throw new Error('Unsupported type for transform');\n  }\n  if (t1.type !== t2.type) {\n    throw new Error('Types are not homogeneous');\n  }\n  return binaryOp(t1, t2, (e1, e2) => (e1 * e2), t1.type);\n}\n  \nexport function div(t1: Tensor, t2: Tensor): Tensor {\n  if ((t1.type !== 'float32' && t1.type !== 'int32') || (t2.type !== 'float32' && t2.type !== 'int32')) {\n    throw new Error('Unsupported type for transform');\n  }\n  if (t1.type !== t2.type) {\n    throw new Error('Types are not homogeneous');\n  }\n  // TODO: Handle division by zero if any\n  return binaryOp(t1, t2, (e1, e2) => (e1 / e2), t1.type);\n}\n\n// Normalization Tensor Transforms\nexport function softmax(t: Tensor, dim = -1): Tensor {\n  if (t.type !== 'float32' && t.type !== 'int32') {\n    throw new Error('Unsupported type for transform');\n  }\n  return softmaxImpl(t, dim);\n}\n  \n// Slice And Join Tensor Transforms\nexport function concat(tensors: Tensor[], axis = 0, typeCheckRequired = true): Tensor {\n  if (tensors.length < 2) {\n    throw new Error('Must have atleast 2 tensors to concatenate');\n  }\n  \n  if(typeCheckRequired) {\n    const types: Type[] = [];\n    tensors.forEach(t => {\n      types.push(t.type);\n    });\n    TypeUtil.validateSameTypes(types);\n  }\n\n  return concatImpl(tensors, axis);\n}\n\nexport function stack(tensors: Tensor[], axis = 0): Tensor {\n  if (tensors.length < 2) {\n    throw new Error('Must have atleast 2 tensors to stack');\n  }\n  \n  const types: Type[] = [];\n  const shapes: Array<ReadonlyArray<number>> = [];\n  tensors.forEach(t => {\n    types.push(t.type);\n    shapes.push(t.dims ? t.dims : [t.data.length]);\n  });\n  TypeUtil.validateSameTypes(types);\n  ShapeUtil.validateEqualDims(shapes);\n  const rank = tensors[0].dims ? tensors[0].dims.length : 1; \n  axis = ShapeUtil.getActualAxisFromNegativeValue(axis, rank);\n  const expanded = tensors.map(t => expandDims(t, axis));\n  return concat(expanded, axis, false);\n}\n\nexport function gather(t: Tensor, indices: Tensor, axis = 0): Tensor{\n  if(t.type === 'string') {\n    throw new Error('Unspported type for this transformation');\n  }\n  if(indices.type !== 'int32' || (indices.dims && indices.dims.length > 1)) {\n    throw new Error('Indices tensor not of specified format');\n  }\n  const dims = t.dims ? t.dims.slice() : [t.data.length];\n  const newDims = dims;\n  const indicesData = indices.data;\n  newDims[axis] = indicesData.length;\n  const dimsStrides = ShapeUtil.computeStrides(dims);\n  const newDimsStrides = ShapeUtil.computeStrides(newDims);\n  const Y = TypedArrayUtil.createTypedArray(t.type, ShapeUtil.size(newDims));\n  const X = t.data;\n  for (let i = 0; i < Y.length; ++i) {\n    const newLogicalIndex = ShapeUtil.offsetToIndices(i, newDimsStrides);\n    const oldLogicalIndex = newLogicalIndex.slice();\n    oldLogicalIndex[axis] = indicesData[newLogicalIndex[axis]] as number;\n    const oldOffset = ShapeUtil.indicesToOffset(oldLogicalIndex, dimsStrides);\n    Y[i] = X[oldOffset] as number;\n  }\n  return new Tensor(t.type, Y, newDims);\n}\n\nexport function slice(t: Tensor, begin: number[], size: number[]): Tensor{\n  if(t.type === 'string') {\n    throw new Error('Unspported type for this transformation');\n  }\n  const newDimsStride = ShapeUtil.computeStrides(size);\n  const oldDimsStride = ShapeUtil.computeStrides(t.dims ? t.dims : [t.data.length]);\n  const X = t.data;\n  const Y = TypedArrayUtil.createTypedArray(t.type, ShapeUtil.size(size));\n  for (let i = 0; i < Y.length; ++i) {\n    const newLogicalIndex = ShapeUtil.offsetToIndices(i, newDimsStride);\n    const oldLogicalIndex = newLogicalIndex.map((idx:any, j:any) => idx + begin[j]);\n    const oldOffset = ShapeUtil.indicesToOffset(oldLogicalIndex, oldDimsStride);\n    Y[i] = X[oldOffset] as number;\n  }\n  return new Tensor(t.type, Y, size);\n}\n  \nexport function tile(t: Tensor, reps: ReadonlyArray<number>): Tensor{\n  if(t.type === 'string') {\n    throw new Error('Unspported type for this transformation');\n  }\n  const dims = t.dims ? t.dims : [t.data.length];\n  const rank = dims.length;\n  const newDims = new Array(rank);\n  if(rank !== reps.length) {\n    throw new Error('Repetitions must be of the same rank as input dims');\n  }\n  for (let i = 0; i < rank; i++) {\n    newDims[i] = dims[i] * reps[i];\n  }\n  const dimsStrides = ShapeUtil.computeStrides(dims);\n  const newDimsStrides = ShapeUtil.computeStrides(newDims);\n  const Y = TypedArrayUtil.createTypedArray(t.type, ShapeUtil.size(newDims));\n  const X = t.data;\n  for (let i = 0; i < Y.length; ++i) {\n    const newLogicalIndex = ShapeUtil.offsetToIndices(i, newDimsStrides);\n    const oldLogicalIndex = new Array(rank);\n    for (let j = 0; j < rank; ++j) {\n      oldLogicalIndex[j] = newLogicalIndex[j] % t.dims[j];\n    }\n    const oldOffset = ShapeUtil.indicesToOffset(oldLogicalIndex, dimsStrides);\n    Y[i] = X[oldOffset] as number;\n  }\n  return new Tensor(t.type, Y, newDims);\n} \n\n// Permutation Tensor Transforms\nexport function transpose(t: Tensor, perm?: number[]): Tensor {\n  return transposeImpl(t, perm);\n}\n\n// Shape Tensor Transforms\nexport function expandDims(t: Tensor, axis = 0): Tensor {\n  axis = ShapeUtil.getActualAxisFromNegativeValue(axis, t.dims ? t.dims.length : 1);\n  const dims = t.dims ? t.dims : [t.data.length];\n  const changedShapeLength = dims.length + 1;\n  const changedShape = new Array<number>(changedShapeLength);\n  let iter = 0;\n  for (let i = 0; i < changedShapeLength; ++i) {\n    if (i === axis) {\n      changedShape[i] = 1;\n    } else {\n      changedShape[i] = dims[iter++];\n    }\n  }\n  return new Tensor(t.type, t.data, changedShape);\n}\n  \n// Logical Tensor Transforms\nexport function greaterEqual(t1: Tensor, t2: Tensor): Tensor {\n  if ((t1.type !== 'float32' && t1.type !== 'int32' && t1.type !== 'bool') \n  || (t2.type !== 'float32' && t2.type !== 'int32' && t2.type !== 'bool')) {\n    throw new Error('Unsupported type for transform');\n  }\n  if (t1.type !== t2.type) {\n    throw new Error('Types are not homogeneous');\n  }\n  return binaryOp(t1, t2, (e1, e2) => (e1 >= e2 ? 1 : 0), 'bool');\n}\n  \nexport function where(condition: Tensor, t1: Tensor, t2: Tensor): Tensor {\n  // validate shape and types of input tensors and condition tensor\n  ShapeUtil.areEqual(t1.dims ? t1.dims : [t1.data.length], t2.dims ? t2.dims : [t2.data.length]);\n  TypeUtil.validateSameTypes([t1.type, t2.type]);\n  if(condition.type !== 'bool') {\n    throw new Error('Condition tensor must be bool type');\n  }\n\n  // create output\n  const outputShape = t1.dims ? t1.dims : [t1.data.length];\n  const output = new Tensor(t1.type, TypedArrayUtil.createTypedArray(t1.type, ShapeUtil.size(outputShape)), \n                          outputShape);\n  const outputData = output.data;\n  \n  // input data\n  const conditionData = condition.data;\n  const X = t1.data;\n  const Y = t2.data;\n\n  // condition is 1D rank\n  if(!condition.dims || condition.dims.length === 1) {\n    // the outermost dimension of the input tensors and condition tensor must be the same\n    const conditionDims = condition.dims ? condition.dims : [condition.data.length];\n    const t1Dims = t1.dims ? t1.dims : [t1.data.length];\n    if (conditionDims[0] !== t1Dims[0]) {\n      throw new Error('Outermost dimensions of input tensors and condition tensor must match');\n    }\n    \n    let offset = 1;\n    // Input tensors are not 1-D. Need to compute offset.\n    if(t1.dims && t1.dims.length > 1) {\n      for(let i = 1; i < t1.dims.length; ++i) {\n        offset *= t1.dims[i];  \n      }\n    }\n\n    for(let i = 0; i < conditionData.length; ++i) {\n      for(let j = 0; j < offset; ++j) {\n        outputData[i*offset + j] = conditionData[i] > 0 ? X[i*offset + j] : Y[i*offset + j];\n      }\n    }\n    \n  } else {\n    // The shapes of input tensors and condition tensor must be the same\n    ShapeUtil.areEqual(condition.dims, t2.dims ? t2.dims : [t2.data.length]);\n    \n    for(let i = 0; i < conditionData.length; ++i) {\n      outputData[i] = conditionData[i] > 0 ? X[i] : Y[i];\n    }\n  }\n  return output; \n}\n  \n// Cast Tensor Transforms\nexport function cast(t: Tensor, dtype: Type): Tensor {\n  // TODO: If the requested type and the given type are the same, return same tensor ?\n  // Need to investigate if it breaks some basic assumptions\n  switch (dtype) {\n      case 'int32':\n      return new Tensor('int32', Int32Array.from(t.data as NumberDataType), t.dims ? t.dims : [t.data.length]);\n      case 'float32':\n      return new Tensor('float32', Float32Array.from(t.data as NumberDataType), t.dims ? t.dims : [t.data.length]);\n      case 'bool':\n      return new Tensor('bool', Uint8Array.from(t.data as NumberDataType), t.dims ? t.dims : [t.data.length]);\n      default:\n      throw new Error('Unsupported type for casting');\n  }\n}\n\nexport function reshape(t: Tensor, dims: ReadonlyArray<number>): Tensor {\n  return reshapeImpl(t, dims);\n}\n\n// Reduction Tensor Transforms\nexport function argMax(t: Tensor, axis = 0): Tensor {\n  if (t.type !== 'float32' && t.type !== 'int32') {\n    throw new Error('Unsupported type for transform');\n  }\n  const rank = t.dims ? t.dims.length : 1;\n  axis = ShapeUtil.getActualAxisFromNegativeValue(axis, rank);\n  const [reduceDims, resultDims] = ShapeUtil.splitDimsIntoTwo(t.dims ? t.dims : [t.data.length], axis);\n  const X = t.data;\n  const Y = TypedArrayUtil.createTypedArray('int32', resultDims.length === 0 ? 1 : ShapeUtil.size(resultDims));\n  const blockSize = reduceDims[0];\n  for (let i = 0; i < Y.length; ++i) {\n    const offset = blockSize * i;\n    let max = X[offset];\n    let index = 0;\n    for (let j = 0; j < blockSize; ++j) {\n      const value = X[offset + j];\n      if (value > max) {\n        max = value;\n        index = j;\n      }\n    }\n    Y[i] = index;\n  }\n  return new Tensor('int32', Y, resultDims.length === 0 ? [1] : resultDims);\n}\n\nexport function max(t: Tensor, axis = 0, keepDims = false): Tensor {\n  if (t.type !== 'float32' && t.type !== 'int32') {\n    throw new Error('Unsupported type for transform');\n  }\n  const rank = t.dims ? t.dims.length : 1;\n  axis = ShapeUtil.getActualAxisFromNegativeValue(axis, rank);\n  const [reduceDims, resultDims] = ShapeUtil.splitDimsIntoTwo(t.dims ? t.dims : [t.data.length], axis);\n  const X = t.data as NumberDataType;\n  const Y = TypedArrayUtil.createTypedArray(t.type, resultDims.length === 0 ? 1 : ShapeUtil.size(resultDims));\n  const blockSize = reduceDims[0];\n  for (let i = 0; i < Y.length; ++i) {\n    const offset = blockSize * i;\n    let max = X[offset];\n    for (let j = 0; j < blockSize; ++j) {\n      const value = X[offset + j];\n      if (value > max) {\n        max = value;\n      }\n    }\n    Y[i] = max;\n  }\n\n  let adjustedResultDims: number[] = [];\n  if(keepDims) {\n    const origDims = t.dims ? t.dims : [t.data.length];  \n    for(let i = 0; i < origDims.length; ++i) {\n        if(i === axis) {\n          adjustedResultDims.push(1);\n        } else {\n          adjustedResultDims.push(origDims[i]);\n        }   \n    } \n  } else {\n    adjustedResultDims = resultDims;\n  }\n  return new Tensor(t.type, Y, adjustedResultDims.length === 0 ? [1] : adjustedResultDims);\n}\n","import {Tensor} from 'onnxruntime-web';\nimport {TypedArrayUtil} from './yoloPostprocessUtils';\n\nexport function sigmoid(input: Tensor) : Tensor {\n  const X = input.data;\n  const Y = TypedArrayUtil.createTypedArray(input.type, X.length);\n  for (let i = 0; i < X.length; i++) {\n    Y[i] = (1 / (1 + Math.exp(-X[i] as number)));\n  }\n  return new Tensor(input.type, Y, input.dims ? input.dims : [input.data.length]);\n}\n\nexport function exp(input: Tensor) : Tensor {\n  if(input.type === 'string') {\n    throw new Error('Unsupported type for transform');\n  }\n  const X = input.data;\n  const Y = TypedArrayUtil.createTypedArray(input.type, X.length);\n  for (let i = 0; i < X.length; i++) {\n    Y[i] = Math.exp(X[i] as number);\n  }\n  return new Tensor(input.type, Y, input.dims ? input.dims : [input.data.length]);\n}","import {Tensor} from 'onnxruntime-web';\nimport {ShapeUtil, TypedArrayUtil} from './yoloPostprocessUtils';\n\nexport function reshape(x: Tensor, shape: ReadonlyArray<number>): Tensor {\n  const reshapedDims = ShapeUtil.calculateReshapedDims(x.dims, shape);\n  const output = new Tensor(x.type, TypedArrayUtil.createTypedArray(x.type, x.data.length), reshapedDims);\n  const X = x.data;\n  const Y = output.data;\n  for(let i = 0; i < x.data.length; ++i) {\n    Y[i] = X[i];\n  }\n  return output;\n}\n","export default [\n    'Aeroplane',\n    'Bicycle',\n    'Bird',\n    'Boat',\n    'Bottle',\n    'Bus',\n    'Car',\n    'Cat',\n    'Chair',\n    'Cow',\n    'Diningtable',\n    'Dog',\n    'Horse',\n    'Motorbike',\n    'Person',\n    'Pottedplant',\n    'Sheep',\n    'Sofa',\n    'Train',\n    'Tvmonitor'\n  ];","import { InferenceSession, Tensor } from \"onnxruntime-web\";\nimport { IOnnxModel } from \"../onnx-model\";\nimport * as yolo from \"./utils/yoloPostprocess\";\nimport classNames from \"./model/yolo_classes\";\nimport { transpose } from \"./utils/transpose\";\n\nconst ndarray = require(\"ndarray\");\nconst ops = require(\"ndarray-ops\");\nconst ort = require(\"onnxruntime-web\");\n\nconst YOLO_ANCHORS = new Tensor(\n    \"float32\",\n    [1.08, 1.19, 3.42, 4.41, 6.63, 11.38, 9.42, 5.11, 16.62, 10.52],\n    [5, 2]\n  );\nconst DEFAULT_FILTER_BOXES_THRESHOLD = 0.01;\nconst DEFAULT_IOU_THRESHOLD = 0.4;\nconst DEFAULT_CLASS_PROB_THRESHOLD = 0.3;\nconst INPUT_DIM = 416;\n\ntype PreprocessOut = Tensor;\n\nexport class Yolo implements IOnnxModel {\n  session: InferenceSession;\n\n  constructor() {\n    const model = require(\"./model/tinyyolov2-7.onnx\");\n    this.session = ort.InferenceSession.create(model.default);\n  }\n\n  async run(img: ImageData) {\n    let inputTensor = this.preprocess(img);\n    const feeds = { image: inputTensor };\n\n    const session = await this.session;\n    const results = await session.run(feeds);\n\n    const originalOutput = new Tensor('float32', results.grid.data as Float32Array, [1, 125, 13, 13]);\n    const outputTensor = transpose(originalOutput, [0, 2, 3, 1]);\n\n    let bboxes = await this.postprocess(outputTensor, 20);\n    console.log(bboxes);\n    return bboxes;\n  }\n\n  preprocess(imageData: ImageData): PreprocessOut {\n    const { data, width, height } = imageData;\n\n    // data processing\n    const dataTensor = ndarray(new Float32Array(data), [width, height, 4]);\n    const dataProcessedTensor = ndarray(new Float32Array(width * height * 3), [\n      1,\n      3,\n      width,\n      height,\n    ]);\n\n    ops.assign(\n      dataProcessedTensor.pick(0, 0, null, null),\n      dataTensor.pick(null, null, 0)\n    );\n    ops.assign(\n      dataProcessedTensor.pick(0, 1, null, null),\n      dataTensor.pick(null, null, 1)\n    );\n    ops.assign(\n      dataProcessedTensor.pick(0, 2, null, null),\n      dataTensor.pick(null, null, 2)\n    );\n\n    const tensor = new Tensor(\"float32\", dataProcessedTensor.data, [\n      1,\n      3,\n      width,\n      height,\n    ]);\n    return tensor;\n  }\n  \n  async postprocess(outputTensor: Tensor, numClasses: number) {\n    const [boxXy, boxWh, boxConfidence, boxClassProbs] = this.yolo_head(\n      outputTensor,\n      YOLO_ANCHORS,\n      20\n    );\n    const allBoxes = this.yolo_boxes_to_corners(boxXy, boxWh);\n    const [outputBoxes, scores, classes] = await this.yolo_filter_boxes(\n      allBoxes,\n      boxConfidence,\n      boxClassProbs,\n      DEFAULT_FILTER_BOXES_THRESHOLD\n    );\n    // If all boxes have been filtered out\n    if (outputBoxes == null) {\n      return [];\n    }\n  \n    const width = yolo.scalar(INPUT_DIM);\n    const height = yolo.scalar(INPUT_DIM);\n  \n    const imageDims = yolo.reshape(\n      yolo.stack([height, width, height, width]),\n      [1, 4]\n    );\n  \n    const boxes: Tensor = yolo.mul(outputBoxes, imageDims);\n  \n    const [preKeepBoxesArr, scoresArr] = await Promise.all([\n      boxes.data,\n      scores.data,\n    ]);\n  \n    const [keepIndx, boxesArr, keepScores] = this.non_max_suppression(\n      preKeepBoxesArr as Float32Array | Int32Array | Uint8Array,\n      scoresArr as Float32Array | Int32Array | Uint8Array,\n      DEFAULT_IOU_THRESHOLD\n    );\n  \n    const classesIndxArr = (await yolo.gather(\n      classes,\n      new Tensor(\"int32\", keepIndx)\n    ).data) as Float32Array;\n  \n    const results: any[] = [];\n  \n    classesIndxArr.forEach((classIndx, i) => {\n      const classProb = keepScores[i];\n      if (classProb < DEFAULT_CLASS_PROB_THRESHOLD) {\n        return;\n      }\n  \n      const className = classNames[classIndx];\n      let [top, left, bottom, right] = boxesArr[i];\n  \n      top = Math.max(0, top);\n      left = Math.max(0, left);\n      bottom = Math.min(416, bottom);\n      right = Math.min(416, right);\n  \n      const resultObj = {\n        className,\n        classProb,\n        bottom,\n        top,\n        left,\n        right,\n      };\n  \n      results.push(resultObj);\n    });\n    return results;\n  }\n  \n  async yolo_filter_boxes(\n    boxes: Tensor,\n    boxConfidence: Tensor,\n    boxClassProbs: Tensor,\n    threshold: number\n  ) {\n    const boxScores = yolo.mul(boxConfidence, boxClassProbs);\n    const boxClasses = yolo.argMax(boxScores, -1);\n    const boxClassScores = yolo.max(boxScores, -1);\n    // Many thanks to @jacobgil\n    // Source: https://github.com/ModelDepot/tfjs-yolo-tiny/issues/6#issuecomment-387614801\n    const predictionMask = yolo.as1D(\n      yolo.greaterEqual(boxClassScores, yolo.scalar(threshold))\n    );\n  \n    const N = predictionMask.size;\n    // linspace start/stop is inclusive.\n    const allIndices = yolo.cast(yolo.linspace(0, N - 1, N), \"int32\");\n    const negIndices = yolo.zeros([N], \"int32\");\n    const indices = yolo.where(predictionMask, allIndices, negIndices);\n  \n    return [\n      yolo.gather(yolo.reshape(boxes, [N, 4]), indices),\n      yolo.gather(yolo.as1D(boxClassScores), indices),\n      yolo.gather(yolo.as1D(boxClasses), indices),\n    ];\n  }\n  \n  /**\n   * Given XY and WH tensor outputs of yolo_head, returns corner coordinates.\n   * @param {Tensor} box_xy Bounding box center XY coordinate Tensor\n   * @param {Tensor} box_wh Bounding box WH Tensor\n   * @returns {Tensor} Bounding box corner Tensor\n   */\n  \n  yolo_boxes_to_corners(boxXy: Tensor, boxWh: Tensor) {\n    const two = new Tensor(\"float32\", [2.0]);\n    const boxMins = yolo.sub(boxXy, yolo.div(boxWh, two));\n    const boxMaxes = yolo.add(boxXy, yolo.div(boxWh, two));\n  \n    const dim0 = boxMins.dims[0];\n    const dim1 = boxMins.dims[1];\n    const dim2 = boxMins.dims[2];\n    const size = [dim0, dim1, dim2, 1];\n  \n    return yolo.concat(\n      [\n        yolo.slice(boxMins, [0, 0, 0, 1], size),\n        yolo.slice(boxMins, [0, 0, 0, 0], size),\n        yolo.slice(boxMaxes, [0, 0, 0, 1], size),\n        yolo.slice(boxMaxes, [0, 0, 0, 0], size),\n      ],\n      3\n    );\n  }\n  \n  /**\n   * Filters/deduplicates overlapping boxes predicted by YOLO. These\n   * operations are done on CPU as AFAIK, there is no tfjs way to do it\n   * on GPU yet.\n   * @param {TypedArray} boxes Bounding box corner data buffer from Tensor\n   * @param {TypedArray} scores Box scores data buffer from Tensor\n   * @param {Number} iouThreshold IoU cutoff to filter overlapping boxes\n   */\n   non_max_suppression(\n    boxes: Float32Array | Int32Array | Uint8Array,\n    scores: Float32Array | Int32Array | Uint8Array,\n    iouThreshold: number\n  ) {\n    // Zip together scores, box corners, and index\n    const zipped = [];\n    for (let i = 0; i < scores.length; i++) {\n      zipped.push([\n        scores[i],\n        [boxes[4 * i], boxes[4 * i + 1], boxes[4 * i + 2], boxes[4 * i + 3]],\n        i,\n      ]);\n    }\n\n    // Sort by descending order of scores (first index of zipped array)\n    const sortedBoxes = zipped.sort((a:any, b:any) => b[0] - a[0]);\n  \n    const selectedBoxes: any[] = [];\n  \n    // Greedily go through boxes in descending score order and only\n    // return boxes that are below the IoU threshold.\n    sortedBoxes.forEach((box: any[]) => {\n      let add = true;\n      for (let i = 0; i < selectedBoxes.length; i++) {\n        // Compare IoU of zipped[1], since that is the box coordinates arr\n        // TODO: I think there's a bug in this calculation\n        const curIou = this.box_iou(box[1], selectedBoxes[i][1]);\n        if (curIou > iouThreshold) {\n          add = false;\n          break;\n        }\n      }\n      if (add) {\n        selectedBoxes.push(box);\n      }\n    });\n  \n    // Return the kept indices and bounding boxes\n    return [\n      selectedBoxes.map((e) => e[2]),\n      selectedBoxes.map((e) => e[1]),\n      selectedBoxes.map((e) => e[0]),\n    ];\n  }\n  \n  // Convert yolo output to bounding box + prob tensors\n  yolo_head(feats: Tensor, anchors: Tensor, numClasses: number) {\n    const numAnchors = anchors.dims[0];\n  \n    const anchorsArray = yolo.reshape(anchors, [1, 1, numAnchors, 2]);\n  \n    const convDims = feats.dims.slice(1, 3);\n  \n    // For later use\n    const convDims0 = convDims[0];\n    const convDims1 = convDims[1];\n  \n    let convHeightIndex = yolo.range(0, convDims[0]);\n    let convWidthIndex = yolo.range(0, convDims[1]);\n  \n    convHeightIndex = yolo.tile(convHeightIndex, [convDims[1]]);\n  \n    convWidthIndex = yolo.tile(yolo.expandDims(convWidthIndex, 0), [\n      convDims[0],\n      1,\n    ]);\n    convWidthIndex = yolo.as1D(yolo.transpose(convWidthIndex));\n   \n    let convIndex = yolo.transpose(yolo.stack([convHeightIndex, convWidthIndex]));\n    convIndex = yolo.reshape(convIndex, [convDims[0], convDims[1], 1, 2]);\n    convIndex = yolo.cast(convIndex, feats.type);\n  \n    feats = yolo.reshape(feats, [\n      convDims[0],\n      convDims[1],\n      numAnchors,\n      numClasses + 5,\n    ]);\n    const convDimsTensor = yolo.cast(\n      yolo.reshape(new Tensor(\"int32\", convDims), [1, 1, 1, 2]),\n      feats.type\n    );\n  \n    let boxXy = yolo.sigmoid(\n      yolo.slice(feats, [0, 0, 0, 0], [convDims0, convDims1, numAnchors, 2])\n    );\n    let boxWh = yolo.exp(\n      yolo.slice(feats, [0, 0, 0, 2], [convDims0, convDims1, numAnchors, 2])\n    );\n    const boxConfidence = yolo.sigmoid(\n      yolo.slice(feats, [0, 0, 0, 4], [convDims0, convDims1, numAnchors, 1])\n    );\n    const boxClassProbs = yolo.softmax(\n      yolo.slice(\n        feats,\n        [0, 0, 0, 5],\n        [convDims0, convDims1, numAnchors, numClasses]\n      )\n    );\n  \n    boxXy = yolo.div(yolo.add(boxXy, convIndex), convDimsTensor);\n    boxWh = yolo.div(yolo.mul(boxWh, anchorsArray), convDimsTensor);\n    // boxXy = tf.mul(tf.add(boxXy, convIndex), 32);\n    // boxWh = tf.mul(tf.mul(boxWh, anchorsArray), 32);\n    return [boxXy, boxWh, boxConfidence, boxClassProbs];\n  }\n  \n  box_intersection(a: number[], b: number[]) {\n    const w = Math.min(a[3], b[3]) - Math.max(a[1], b[1]);\n    const h = Math.min(a[2], b[2]) - Math.max(a[0], b[0]);\n    if (w < 0 || h < 0) {\n      return 0;\n    }\n    return w * h;\n  }\n  \n  box_union(a: number[], b: number[]) {\n    const i = this.box_intersection(a, b);\n    return (a[3] - a[1]) * (a[2] - a[0]) + (b[3] - b[1]) * (b[2] - b[0]) - i;\n  }\n  \n  box_iou(a: number[], b: number[]) {\n    return this.box_intersection(a, b) / this.box_union(a, b);\n  }\n}\n","import { IOnnxModel } from \"../onnx/onnx-model\";\nimport { Yolo } from \"../onnx/yolo/yolo\";\n\n/** \n * Loads a video from url\n */\nexport class VideoLoader {\n    video: HTMLVideoElement;\n    canvas: HTMLCanvasElement;\n    ctx: CanvasRenderingContext2D | null;\n    model: IOnnxModel;\n\n    constructor(video:HTMLVideoElement, canvas:HTMLCanvasElement) {\n        // this.video = document.createElement('video');\n        this.video = video\n        // this.video.src = url;\n        // this.canvas = document.createElement('canvas');\n        this.canvas = canvas;\n        this.canvas.width = 416;\n        this.canvas.height = 416;\n        this.ctx = this.canvas.getContext(\"2d\");\n        this.model = new Yolo();\n    }\n\n    async processFrames(fps: number) {\n        this.video.currentTime = 0;\n        \n        this.video.onseeked = async () => {\n            if (!this.ctx) {\n                return;\n            }\n            \n            const canvasHeight = this.ctx.canvas.height;\n            const canvasWidth = this.ctx.canvas.width;\n\n            let height = this.video.videoHeight;\n            let width = this.video.videoWidth;\n\n            if (height > canvasHeight) {\n                let multiplier = (canvasHeight / height);\n                height *= multiplier;\n                width *= multiplier;\n            }\n            \n            if (width > canvasWidth) {\n                let multiplier = (canvasWidth / width);\n                height *= multiplier;\n                width *= multiplier;\n            }\n\n            const offset_x = (canvasWidth - width) / 2;\n            const offset_y = (canvasHeight - height) / 2;\n\n            this.ctx.clearRect(0,0,canvasWidth, canvasHeight);\n            this.ctx.drawImage(this.video, offset_x, offset_y, width, height);\n            let imgData = this.ctx.getImageData(0, 0, canvasWidth, canvasHeight);\n            let bboxes = await this.model.run(imgData);\n            bboxes.forEach((bbox: any) => {         \n                if (this.ctx == null) return;\n                // label\n                this.ctx.font = \"10px Arial\"                \n                this.ctx.fillStyle = \"red\";\n                this.ctx.fillText(bbox.className, bbox.left, bbox.top + 10);\n                \n                // bbox\n                this.ctx.beginPath();                \n                this.ctx.lineWidth = 4;\n                this.ctx.strokeStyle = \"red\";\n                this.ctx.rect(bbox.left, bbox.top, (bbox.right-bbox.left), (bbox.bottom - bbox.top));\n                this.ctx.stroke();\n            })\n        }\n\n    }\n\n    cloneVideo(){\n        this.video.ontimeupdate = () => {\n            this.ctx?.drawImage(this.video, 0, 0, this.video.videoWidth, this.video.videoHeight);      \n        }\n    }\n}\n","import { useEffect, useRef } from 'react';\nimport './App.css';\nimport { VideoLoader } from './common/video-loader';\n\nfunction App() {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  \n  useEffect(() => {\n    if (videoRef.current != null && canvasRef.current != null){\n      const videoLoader = new VideoLoader(videoRef.current, canvasRef.current);\n      videoLoader.processFrames(60); \n      // videoLoader.cloneVideo();     \n    }  \n  })\n\n  const video = require('./videos/sample_720p.mp4');\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <div>\n          <video ref={videoRef} src={video.default} controls={true}/>\n        </div>\n        <div>\n          <canvas ref={canvasRef} width=\"160\" height=\"96\"></canvas>          \n        </div>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>    \n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}